// SPDX-License-Identifier: MIT
pragma solidity 0.8.2;

import "@openzeppelin/contracts/access/Ownable.sol";
import "../AirnodeRrp.sol";
import "../AirnodeRrpClient.sol";
import "./interfaces/IAggregator.sol";

/**
 * @title A sample dAPI/aggregator contract
 * @dev only owner can trigger request
 */
contract MemorylessAggregator is IAggregator, AirnodeRrpClient, Ownable {

    bytes32[] public templateIds;
    uint256 public requesterIndex;
    address public designatedWallet;
    uint128 public minimumResponses;

    uint256 public aggregatedAnswer;

    address private _fulfillAddress;
    bytes4 private _fulfillFunctionId;
    mapping (bytes => bool) private _pendingRequests;
    // individual answers from Airnodes are stored in an array
    uint256[] private _individualAnswers;

    event NewUpdateRequested(uint256 timestamp);
    event RequestFulfilled(uint256 requestId);
    event AggregatedAnswerUpdated(uint256 timestamp, uint256 aggregatedAnswer);
    
    constructor
    (
        bytes32[] memory _templateIds,
        uint256 _requesterIndex,
        address _designatedWallet,
        uint128 _minimumResponses
    )
        public
    {
        updateRequestData(
            _templateIds,
            _requesterIndex,
            _designatedWallet,
            _minimumResponses
        );
        _fulfillAddress = address(this);
        _fulfillFunctionId = bytes4(keccak256("onFulfill(bytes32,uint256,bytes)"));
    }

    /**
     * @notice Creates a request to each Airnode via the template array.
     * @dev This call assumes no additional parameters are required. That is,
     * all necessary parameters for all future requests are in the `Template`
     * struct referenced by `templateIds`.
     */
    function requestUpdatedAnswer()
    external
    onlyOwner()
    {
        bytes32 requestId;

        for (uint i = 0; i < templateIds.length; i++) {
            requestId = AirnodeRrp.makeRequest(
                templateIds[i],
                requesterIndex,
                designatedWallet,
                _fulfillAddress,
                _fulfillFunctionId,
                "" // no additional parameters passed
            );
        }
        _emptyAnswerArray();
        emit NewUpdateRequested(block.timestamp);
    }

    /**
     * @notice Handles fulfill from Airnode
     * @dev `statusCode` being zero indicates a successful fulfillment, while
     * non-zero values indicate error (the meanings of these values are
     * implementation-dependent).
     */
    function onFulfill
    (
        bytes32 requestId,
        uint256 statusCode,
        bytes calldata data
    )
        external
        onlyAirnodeRrp()
    {
        if (!statusCode && _pendingRequests[requestId]) {
            delete _pendingRequests[msg.sender];
            emit RequestFulfilled(requestId);
            
            uint256 decodedData = abi.decode(data, uint256);
            _individualAnswers.push(decodedData);

            if (_individualAnswers.length >= minimumResponses) {
                //_updateAggregateAnswer();
            }
        }
    }

    function updateRequestData
    (
        bytes32[] calldata _templateIds,
        uint256 _requesterIndex,
        address _designatedWallet,
        uint128 _minimumResponses
    )
        public
        onlyOwner
    {
        // TODO: validate
        templateIds = _templateIds;
        requesterIndex = _requesterIndex;
        designatedWallet = _designatedWallet;
        minimumResponses = _minimumResponses;
    }

    function _emptyAnswerArray() private
    {
        for (uint i=0; i<_individualAnswers.length; i++) {
            delete _individualAnswers[i];
        }
    }

    //function _updateAggregateAnswer() private
    //{
    //    uint256 median = Median.compute(_individualAnswers);
    //    aggregatedAnswer = median;
    //    emit AggregatedAnswerUpdated(block.timestamp, aggregatedAnswer);
    //}
}
