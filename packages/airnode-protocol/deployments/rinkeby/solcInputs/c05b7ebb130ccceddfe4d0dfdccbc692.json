{
  "language": "Solidity",
  "sources": {
    "contracts/access-control-registry/AccessControlAgent.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IAccessControlRegistry.sol\";\nimport \"./interfaces/IAccessControlAgent.sol\";\n\n/// @title Contract that acts as an agent that will interact with\n/// AccessControlRegistry\n/// @notice AccessControlRegistry users that want their access control tables\n/// to be transferrable (e.g., a DAO) will use this. There are cases where this\n/// transferrability is not desired, e.g., if the user is an Airnode and is\n/// immutably associated with a single address.\ncontract AccessControlAgent is Ownable, IAccessControlAgent {\n    /// @notice Address of the AccessControlRegistry contract that this\n    /// contract interfaces with\n    address public immutable override accessControlRegistry;\n\n    /// @param _accessControlRegistry Address of the AccessControlRegistry\n    /// contract\n    constructor(address _accessControlRegistry) {\n        require(_accessControlRegistry != address(0), \"ACR address zero\");\n        accessControlRegistry = _accessControlRegistry;\n    }\n\n    /// @notice Initializes a role, which includes setting its admin,\n    /// associating it with its manager and granting it to the sender\n    /// @dev See AccessControlRegistry.sol for details\n    /// @param adminRole Admin role to be assigned to the initialized role\n    /// @param description Human-readable description of the initialized role\n    /// @return role Initialized role\n    function initializeRole(bytes32 adminRole, string calldata description)\n        external\n        override\n        onlyOwner\n        returns (bytes32 role)\n    {\n        role = IAccessControlRegistry(accessControlRegistry).initializeRole(\n            adminRole,\n            description\n        );\n    }\n\n    /// @notice Initializes roles and grants them to the respective accounts\n    /// @dev See AccessControlRegistry.sol for details\n    /// @param adminRoles Admin role to be assigned to the initialized roles\n    /// @param descriptions Human-readable descriptions of the initialized\n    /// roles\n    /// @param accounts Accounts the initialized roles will be granted to\n    /// @return roles Initialized roles\n    function initializeAndGrantRoles(\n        bytes32[] calldata adminRoles,\n        string[] calldata descriptions,\n        address[] calldata accounts\n    ) external override onlyOwner returns (bytes32[] memory roles) {\n        roles = IAccessControlRegistry(accessControlRegistry)\n            .initializeAndGrantRoles(adminRoles, descriptions, accounts);\n    }\n\n    /// @notice Grants role\n    /// @dev See AccessControl.sol for details\n    /// @param role Role to be granted\n    /// @param account Account that the role will be granted to\n    function grantRole(bytes32 role, address account)\n        external\n        override\n        onlyOwner\n    {\n        IAccessControlRegistry(accessControlRegistry).grantRole(role, account);\n    }\n\n    /// @notice Revokes role\n    /// @dev See AccessControl.sol for details\n    /// @param role Role to be revoked\n    /// @param account Account that the role will be revoked from\n    function revokeRole(bytes32 role, address account)\n        external\n        override\n        onlyOwner\n    {\n        IAccessControlRegistry(accessControlRegistry).revokeRole(role, account);\n    }\n\n    /// @notice Renounces role\n    /// @dev See AccessControlRegistry.sol for details\n    /// @param role Role to be renounced\n    /// @param account Account to renounce the role\n    function renounceRole(bytes32 role, address account)\n        external\n        override\n        onlyOwner\n    {\n        IAccessControlRegistry(accessControlRegistry).renounceRole(\n            role,\n            account\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/access-control-registry/interfaces/IAccessControlRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\ninterface IAccessControlRegistry is IAccessControl {\n    event InitializedManager(address indexed manager, bytes32 rootRole);\n\n    event InitializedRole(\n        bytes32 indexed role,\n        bytes32 indexed adminRole,\n        string description,\n        address sender\n    );\n\n    function initializeManager(address manager) external;\n\n    function initializeRole(bytes32 adminRole, string calldata description)\n        external\n        returns (bytes32 role);\n\n    function initializeAndGrantRoles(\n        bytes32[] calldata adminRoles,\n        string[] calldata descriptions,\n        address[] calldata accounts\n    ) external returns (bytes32[] memory roles);\n\n    function deriveRootRole(address manager)\n        external\n        pure\n        returns (bytes32 rootRole);\n\n    function deriveRole(bytes32 adminRole, string calldata description)\n        external\n        pure\n        returns (bytes32 role);\n}\n"
    },
    "contracts/access-control-registry/interfaces/IAccessControlAgent.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface IAccessControlAgent {\n    function initializeRole(bytes32 adminRole, string calldata description)\n        external\n        returns (bytes32 role);\n\n    function initializeAndGrantRoles(\n        bytes32[] calldata adminRoles,\n        string[] calldata descriptions,\n        address[] calldata accounts\n    ) external returns (bytes32[] memory roles);\n\n    function grantRole(bytes32 role, address account) external;\n\n    function revokeRole(bytes32 role, address account) external;\n\n    function renounceRole(bytes32 role, address account) external;\n\n    function accessControlRegistry() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/rrp/requesters/RrpBeaconServer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../access-control-registry/Whitelist.sol\";\nimport \"../../access-control-registry/WhitelistRolesWithManager.sol\";\nimport \"./RrpRequester.sol\";\nimport \"./interfaces/IRrpBeaconServer.sol\";\nimport \"../../access-control-registry/interfaces/IAccessControlRegistry.sol\";\n\n/// @title The contract that serves beacons using Airnode RRP\n/// @notice A beacon is a live data point associated with a template ID. This\n/// is suitable where the more recent data point is always more favorable,\n/// e.g., in the context of an asset price data feed. Another definition of\n/// beacons are one-Airnode data feeds that can be used individually or\n/// combined to build decentralized data feeds.\n/// @dev This contract casts the reported data point to `int224`. If this is\n/// a problem (because the reported data may not fit into 224 bits or it is of\n/// a completely different type such as `bytes32`), do not use this contract\n/// and implement a customized version instead.\n/// The contract casts the timestamps to `uint32`, which means it will not work\n/// work past-2106 in the current form. If this is an issue, consider casting\n/// the timestamps to a larger type.\ncontract RrpBeaconServer is Whitelist, RrpRequester, IRrpBeaconServer {\n    struct Beacon {\n        int224 value;\n        uint32 timestamp;\n    }\n\n    /// @notice Returns if a sponsor has permitted an account to request\n    /// updates at this contract\n    mapping(address => mapping(address => bool))\n        public\n        override sponsorToUpdateRequesterToPermissionStatus;\n\n    mapping(bytes32 => Beacon) private templateIdToBeacon;\n    mapping(bytes32 => bytes32) private requestIdToTemplateId;\n\n    /// @dev Reverts if the template with the ID is not created\n    /// @param templateId Template ID\n    modifier onlyIfTemplateExists(bytes32 templateId) {\n        (address airnode, , ) = airnodeRrp.templates(templateId);\n        require(airnode != address(0), \"Template does not exist\");\n        _;\n    }\n\n    /// @param _airnodeRrp Airnode RRP contract address\n    constructor(address _airnodeRrp) RrpRequester(_airnodeRrp) {}\n\n    /// @notice Extends the expiration of the temporary whitelist of `reader`\n    /// to be able to read the beacon with `templateId` if the sender has the\n    /// whitelist expiration extender role\n    /// @param templateId Template ID\n    /// @param reader Reader address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function _extendWhitelistExpirationAndEmit(\n        bytes32 templateId,\n        address reader,\n        uint64 expirationTimestamp\n    ) internal {\n        _extendWhitelistExpiration(templateId, reader, expirationTimestamp);\n        emit ExtendedWhitelistExpiration(\n            templateId,\n            reader,\n            msg.sender,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the expiration of the temporary whitelist of `reader` to\n    /// be able to read the beacon with `templateId` if the sender has the\n    /// whitelist expiration extender role\n    /// @param templateId Template ID\n    /// @param reader Reader address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function _setWhitelistExpirationAndEmit(\n        bytes32 templateId,\n        address reader,\n        uint64 expirationTimestamp\n    ) internal {\n        _setWhitelistExpiration(templateId, reader, expirationTimestamp);\n        emit SetWhitelistExpiration(\n            templateId,\n            reader,\n            msg.sender,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the indefinite whitelist status of `reader` to be able to\n    /// read the beacon with `templateId` if the sender has the indefinite\n    /// whitelister role\n    /// @param templateId Template ID\n    /// @param reader Reader address\n    /// @param status Indefinite whitelist status\n    function _setIndefiniteWhitelistStatusAndEmit(\n        bytes32 templateId,\n        address reader,\n        bool status\n    ) internal {\n        uint192 indefiniteWhitelistCount = _setIndefiniteWhitelistStatus(\n            templateId,\n            reader,\n            status\n        );\n        emit SetIndefiniteWhitelistStatus(\n            templateId,\n            reader,\n            msg.sender,\n            status,\n            indefiniteWhitelistCount\n        );\n    }\n\n    /// @notice Revokes the indefinite whitelist status granted by a specific\n    /// account that no longer has the indefinite whitelister role\n    /// @param templateId Template ID\n    /// @param reader Reader address\n    /// @param setter Setter of the indefinite whitelist status\n    function _revokeIndefiniteWhitelistStatusAndEmit(\n        bytes32 templateId,\n        address reader,\n        address setter\n    ) internal {\n        (\n            bool revoked,\n            uint192 indefiniteWhitelistCount\n        ) = _revokeIndefiniteWhitelistStatus(templateId, reader, setter);\n        if (revoked) {\n            emit RevokedIndefiniteWhitelistStatus(\n                templateId,\n                reader,\n                setter,\n                msg.sender,\n                indefiniteWhitelistCount\n            );\n        }\n    }\n\n    /// @notice Called by the sponsor to set the update request permission\n    /// status of an account\n    /// @param updateRequester Update requester address\n    /// @param status Update permission status of the update requester\n    function setUpdatePermissionStatus(address updateRequester, bool status)\n        external\n        override\n    {\n        require(updateRequester != address(0), \"Update requester zero\");\n        sponsorToUpdateRequesterToPermissionStatus[msg.sender][\n            updateRequester\n        ] = status;\n        emit SetUpdatePermissionStatus(msg.sender, updateRequester, status);\n    }\n\n    /// @notice Called to request a beacon to be updated\n    /// @dev There are two requirements for this method to be called: (1) The\n    /// sponsor must call `setSponsorshipStatus()` of AirnodeRrp to sponsor\n    /// this RrpBeaconServer contract, (2) The sponsor must call\n    /// `setUpdatePermissionStatus()` of this RrpBeaconServer contract to give\n    /// request update permission to the caller of this method.\n    /// The template used here must specify a single point of data of type\n    /// `int256` to be returned because this is what `fulfill()` expects.\n    /// This point of data should be castable to `int224`.\n    /// @param templateId Template ID of the beacon to be updated\n    /// @param sponsor Sponsor whose wallet will be used to fulfill this\n    /// request\n    /// @param sponsorWallet Sponsor wallet that will be used to fulfill this\n    /// request\n    function requestBeaconUpdate(\n        bytes32 templateId,\n        address sponsor,\n        address sponsorWallet\n    ) external override {\n        require(\n            sponsorToUpdateRequesterToPermissionStatus[sponsor][msg.sender],\n            \"Caller not permitted\"\n        );\n        bytes32 requestId = airnodeRrp.makeTemplateRequest(\n            templateId,\n            sponsor,\n            sponsorWallet,\n            address(this),\n            this.fulfill.selector,\n            \"\"\n        );\n        requestIdToTemplateId[requestId] = templateId;\n        emit RequestedBeaconUpdate(\n            templateId,\n            sponsor,\n            msg.sender,\n            requestId,\n            sponsorWallet\n        );\n    }\n\n    /// @notice Called by AirnodeRrp to fulfill the request\n    /// @dev It is assumed that the fulfillment will be made with a single\n    /// point of data of type `int256`\n    /// @param requestId ID of the request being fulfilled\n    /// @param data Fulfillment data (a single `int256` encoded as `bytes`)\n    function fulfill(bytes32 requestId, bytes calldata data)\n        external\n        override\n        onlyAirnodeRrp\n    {\n        bytes32 templateId = requestIdToTemplateId[requestId];\n        require(templateId != bytes32(0), \"No such request made\");\n        delete requestIdToTemplateId[requestId];\n        int256 decodedData = abi.decode(data, (int256));\n        require(\n            decodedData >= type(int224).min && decodedData <= type(int224).max,\n            \"Value typecasting error\"\n        );\n        require(\n            block.timestamp <= type(uint32).max,\n            \"Timestamp typecasting error\"\n        );\n        templateIdToBeacon[templateId] = Beacon({\n            value: int224(decodedData),\n            timestamp: uint32(block.timestamp)\n        });\n        emit UpdatedBeacon(\n            templateId,\n            requestId,\n            int224(decodedData),\n            uint32(block.timestamp)\n        );\n    }\n\n    /// @notice Called to read the beacon\n    /// @dev The caller must be whitelisted.\n    /// If the `timestamp` of a beacon is zero, this means that it was never\n    /// written to before, and the zero value in the `value` field is not\n    /// valid. In general, make sure to check if the timestamp of the beacon is\n    /// fresh enough, and definitely disregard beacons with zero `timestamp`.\n    /// @param templateId Template ID of the beacon that will be returned\n    /// @return value Beacon value\n    /// @return timestamp Beacon timestamp\n    function readBeacon(bytes32 templateId)\n        external\n        view\n        override\n        returns (int224 value, uint32 timestamp)\n    {\n        require(\n            readerCanReadBeacon(templateId, msg.sender),\n            \"Caller not whitelisted\"\n        );\n        Beacon storage beacon = templateIdToBeacon[templateId];\n        return (beacon.value, beacon.timestamp);\n    }\n\n    /// @notice Called to check if a reader is whitelisted to read the beacon\n    /// @param templateId Template ID\n    /// @param reader Reader address\n    /// @return isWhitelisted If the reader is whitelisted\n    function readerCanReadBeacon(bytes32 templateId, address reader)\n        public\n        view\n        override\n        onlyIfTemplateExists(templateId)\n        returns (bool)\n    {\n        return userIsWhitelisted(templateId, reader);\n    }\n\n    /// @notice Called to get the detailed whitelist status of the reader for\n    /// the beacon\n    /// @param templateId Template ID\n    /// @param reader Reader address\n    /// @return expirationTimestamp Timestamp at which the whitelisting of the\n    /// reader will expire\n    /// @return indefiniteWhitelistCount Number of times `reader` was\n    /// whitelisted indefinitely for `templateId`\n    function templateIdToReaderToWhitelistStatus(\n        bytes32 templateId,\n        address reader\n    )\n        external\n        view\n        override\n        onlyIfTemplateExists(templateId)\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount)\n    {\n        WhitelistStatus\n            storage whitelistStatus = serviceIdToUserToWhitelistStatus[\n                templateId\n            ][reader];\n        expirationTimestamp = whitelistStatus.expirationTimestamp;\n        indefiniteWhitelistCount = whitelistStatus.indefiniteWhitelistCount;\n    }\n\n    /// @notice Returns if an account has indefinitely whitelisted the reader\n    /// for the beacon\n    /// @param templateId Template ID\n    /// @param reader Reader address\n    /// @param setter Address of the account that has potentially whitelisted\n    /// the reader for the beacon indefinitely\n    /// @return indefiniteWhitelistStatus If `setter` has indefinitely\n    /// whitelisted reader for the beacon\n    function templateIdToReaderToSetterToIndefiniteWhitelistStatus(\n        bytes32 templateId,\n        address reader,\n        address setter\n    ) external view override returns (bool indefiniteWhitelistStatus) {\n        indefiniteWhitelistStatus = serviceIdToUserToSetterToIndefiniteWhitelistStatus[\n            templateId\n        ][reader][setter];\n    }\n}\n"
    },
    "contracts/access-control-registry/Whitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\n/// @title Contract that implements a generic whitelist\n/// @notice This contract can be inherited and extended to implement temporary\n/// and permanent whitelists\n/// @dev This contract implements two kinds of whitelisting:\n///   (1) Temporary, ends when the expiration timestamp is in the past\n///   (2) Indefinite, ends when the indefinite whitelist count is zero\n/// Multiple senders can grant and revoke indefinite whitelists\n/// independently. The requester will be considered whitelisted as long as\n/// there is at least one active indefinite whitelist.\ncontract Whitelist {\n    struct WhitelistStatus {\n        uint64 expirationTimestamp;\n        uint192 indefiniteWhitelistCount;\n    }\n\n    mapping(bytes32 => mapping(address => WhitelistStatus))\n        internal serviceIdToUserToWhitelistStatus;\n\n    mapping(bytes32 => mapping(address => mapping(address => bool)))\n        internal serviceIdToUserToSetterToIndefiniteWhitelistStatus;\n\n    /// @notice Extends the expiration of the temporary whitelist of\n    /// the user for the service\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function _extendWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) internal {\n        require(\n            expirationTimestamp >\n                serviceIdToUserToWhitelistStatus[serviceId][user]\n                    .expirationTimestamp,\n            \"Does not extend expiration\"\n        );\n        serviceIdToUserToWhitelistStatus[serviceId][user]\n            .expirationTimestamp = expirationTimestamp;\n    }\n\n    /// @notice Sets the expiration of the temporary whitelist of the user for\n    /// the service\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function _setWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) internal {\n        serviceIdToUserToWhitelistStatus[serviceId][user]\n            .expirationTimestamp = expirationTimestamp;\n    }\n\n    /// @notice Sets the indefinite whitelist status of the user for the\n    /// service\n    /// @dev As long as at least there is at least one account that has set the\n    /// indefinite whitelist status of the user for the service as true, the\n    /// user will be considered whitelisted.\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param status Indefinite whitelist status\n    function _setIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        bool status\n    ) internal returns (uint192 indefiniteWhitelistCount) {\n        indefiniteWhitelistCount = serviceIdToUserToWhitelistStatus[serviceId][\n            user\n        ].indefiniteWhitelistCount;\n        if (\n            status &&\n            !serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][\n                user\n            ][msg.sender]\n        ) {\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\n                msg.sender\n            ] = true;\n            indefiniteWhitelistCount++;\n            serviceIdToUserToWhitelistStatus[serviceId][user]\n                .indefiniteWhitelistCount = indefiniteWhitelistCount;\n        } else if (\n            !status &&\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\n                msg.sender\n            ]\n        ) {\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\n                msg.sender\n            ] = false;\n            indefiniteWhitelistCount--;\n            serviceIdToUserToWhitelistStatus[serviceId][user]\n                .indefiniteWhitelistCount = indefiniteWhitelistCount;\n        }\n    }\n\n    /// @notice Revokes the indefinite whitelist status granted to the user for\n    /// the service by a specific account\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param setter Setter of the indefinite whitelist status\n    function _revokeIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        address setter\n    ) internal returns (bool revoked, uint192 indefiniteWhitelistCount) {\n        indefiniteWhitelistCount = serviceIdToUserToWhitelistStatus[serviceId][\n            user\n        ].indefiniteWhitelistCount;\n        if (\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\n                setter\n            ]\n        ) {\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\n                setter\n            ] = false;\n            indefiniteWhitelistCount--;\n            serviceIdToUserToWhitelistStatus[serviceId][user]\n                .indefiniteWhitelistCount = indefiniteWhitelistCount;\n            revoked = true;\n        }\n    }\n\n    /// @notice Returns if the user is whitelised to use the service\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @return isWhitelisted If the user is whitelisted\n    function userIsWhitelisted(bytes32 serviceId, address user)\n        internal\n        view\n        returns (bool isWhitelisted)\n    {\n        WhitelistStatus\n            storage whitelistStatus = serviceIdToUserToWhitelistStatus[\n                serviceId\n            ][user];\n        return\n            whitelistStatus.indefiniteWhitelistCount > 0 ||\n            whitelistStatus.expirationTimestamp > block.timestamp;\n    }\n}\n"
    },
    "contracts/access-control-registry/WhitelistRolesWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./WhitelistRoles.sol\";\nimport \"./interfaces/IWhitelistRolesWithManager.sol\";\n\n/// @title Contract that implements a whitelist controlled by\n/// AccessControlRegistry roles set by a manager\ncontract WhitelistRolesWithManager is\n    WhitelistRoles,\n    IWhitelistRolesWithManager\n{\n    /// @notice Address of the manager that manages the related\n    /// AccessControlRegistry roles\n    address public immutable override manager;\n\n    /// @notice Admin role\n    bytes32 public immutable override adminRole;\n\n    /// @notice Whitelist expiration extender role\n    bytes32 public immutable override whitelistExpirationExtenderRole;\n\n    /// @notice Whitelist expiration setter role\n    bytes32 public immutable override whitelistExpirationSetterRole;\n\n    /// @notice Indefinite whitelister role\n    bytes32 public immutable override indefiniteWhitelisterRole;\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    ) WhitelistRoles(_accessControlRegistry, _adminRoleDescription) {\n        require(_manager != address(0), \"Manager address zero\");\n        manager = _manager;\n        adminRole = _deriveAdminRole(_manager);\n        whitelistExpirationExtenderRole = _deriveWhitelistExpirationExtenderRole(\n            _manager\n        );\n        whitelistExpirationSetterRole = _deriveWhitelistExpirationSetterRole(\n            _manager\n        );\n        indefiniteWhitelisterRole = _deriveIndefiniteWhitelisterRole(_manager);\n    }\n}\n"
    },
    "contracts/rrp/requesters/RrpRequester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../interfaces/IAirnodeRrp.sol\";\n\n/// @title The contract to be inherited to make Airnode RRP requests\ncontract RrpRequester {\n    IAirnodeRrp public immutable airnodeRrp;\n\n    /// @dev Reverts if the caller is not the Airnode RRP contract.\n    /// Use it as a modifier for fulfill and error callback methods, but also\n    /// check `requestId`.\n    modifier onlyAirnodeRrp() {\n        require(msg.sender == address(airnodeRrp), \"Caller not Airnode RRP\");\n        _;\n    }\n\n    /// @dev Airnode RRP address is set at deployment and is immutable.\n    /// RrpRequester is made its own sponsor by default. RrpRequester can also\n    /// be sponsored by others and use these sponsorships while making\n    /// requests, i.e., using this default sponsorship is optional.\n    /// @param _airnodeRrp Airnode RRP contract address\n    constructor(address _airnodeRrp) {\n        airnodeRrp = IAirnodeRrp(_airnodeRrp);\n        IAirnodeRrp(_airnodeRrp).setSponsorshipStatus(address(this), true);\n    }\n}\n"
    },
    "contracts/rrp/requesters/interfaces/IRrpBeaconServer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface IRrpBeaconServer {\n    event ExtendedWhitelistExpiration(\n        bytes32 indexed templateId,\n        address indexed reader,\n        address indexed sender,\n        uint256 expiration\n    );\n\n    event SetWhitelistExpiration(\n        bytes32 indexed templateId,\n        address indexed reader,\n        address indexed sender,\n        uint256 expiration\n    );\n\n    event SetIndefiniteWhitelistStatus(\n        bytes32 indexed templateId,\n        address indexed reader,\n        address indexed sender,\n        bool status,\n        uint192 indefiniteWhitelistCount\n    );\n\n    event RevokedIndefiniteWhitelistStatus(\n        bytes32 indexed templateId,\n        address indexed reader,\n        address indexed setter,\n        address sender,\n        uint192 indefiniteWhitelistCount\n    );\n\n    event SetUpdatePermissionStatus(\n        address indexed sponsor,\n        address indexed updateRequester,\n        bool status\n    );\n\n    event RequestedBeaconUpdate(\n        bytes32 indexed templateId,\n        address indexed sponsor,\n        address indexed requester,\n        bytes32 requestId,\n        address sponsorWallet\n    );\n\n    event UpdatedBeacon(\n        bytes32 indexed templateId,\n        bytes32 requestId,\n        int224 value,\n        uint32 timestamp\n    );\n\n    function setUpdatePermissionStatus(address updateRequester, bool status)\n        external;\n\n    function requestBeaconUpdate(\n        bytes32 templateId,\n        address requester,\n        address designatedWallet\n    ) external;\n\n    function fulfill(bytes32 requestId, bytes calldata data) external;\n\n    function readBeacon(bytes32 templateId)\n        external\n        view\n        returns (int224 value, uint32 timestamp);\n\n    function readerCanReadBeacon(bytes32 templateId, address reader)\n        external\n        view\n        returns (bool);\n\n    function templateIdToReaderToWhitelistStatus(\n        bytes32 templateId,\n        address reader\n    )\n        external\n        view\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount);\n\n    function templateIdToReaderToSetterToIndefiniteWhitelistStatus(\n        bytes32 templateId,\n        address reader,\n        address setter\n    ) external view returns (bool indefiniteWhitelistStatus);\n\n    function sponsorToUpdateRequesterToPermissionStatus(\n        address sponsor,\n        address updateRequester\n    ) external view returns (bool permissionStatus);\n}\n"
    },
    "contracts/access-control-registry/WhitelistRoles.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./RoleDeriver.sol\";\nimport \"./AccessControlClient.sol\";\nimport \"./interfaces/IWhitelistRoles.sol\";\n\n/// @title Contract that implements a whitelist controlled by\n/// AccessControlRegistry roles\ncontract WhitelistRoles is RoleDeriver, AccessControlClient, IWhitelistRoles {\n    // There are four roles in this contract:\n    // Root\n    // └── (1) Admin (can grant and revoke the roles below)\n    //     ├── (2) Whitelist expiration extender\n    //     ├── (3) Whitelist expiration setter\n    //     └── (4) Indefinite whitelister\n    // Their IDs are derived from the descriptions below. Refer to\n    // AccessControlRegistry for more information.\n    string public override adminRoleDescription;\n    string\n        public constant\n        override WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION =\n        \"Whitelist expiration extender\";\n    string\n        public constant\n        override WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION =\n        \"Whitelist expiration setter\";\n    string public constant override INDEFINITE_WHITELISTER_ROLE_DESCRIPTION =\n        \"Indefinite whitelister\";\n    bytes32 internal adminRoleDescriptionHash;\n    bytes32\n        internal constant WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION_HASH =\n        keccak256(\n            abi.encodePacked(WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION)\n        );\n    bytes32\n        internal constant WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION_HASH =\n        keccak256(\n            abi.encodePacked(WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION)\n        );\n    bytes32 internal constant INDEFINITE_WHITELISTER_ROLE_DESCRIPTION_HASH =\n        keccak256(abi.encodePacked(INDEFINITE_WHITELISTER_ROLE_DESCRIPTION));\n\n    /// @dev Contracts deployed with the same admin role descriptions will have\n    /// the same role IDs, meaning that granting an account a role will\n    /// authorize it in multiple contracts. Unless you want your deployed\n    /// contract to reuse the role configuration of another contract, use a\n    /// unique admin role description.\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription\n    ) AccessControlClient(_accessControlRegistry) {\n        require(\n            bytes(_adminRoleDescription).length > 0,\n            \"Admin role description empty\"\n        );\n        adminRoleDescription = _adminRoleDescription;\n        adminRoleDescriptionHash = keccak256(\n            abi.encodePacked(_adminRoleDescription)\n        );\n    }\n\n    /// @notice Derives the admin role for the specific manager address\n    /// @param manager Manager address\n    /// @return adminRole Admin role\n    function _deriveAdminRole(address manager)\n        internal\n        view\n        returns (bytes32 adminRole)\n    {\n        adminRole = _deriveRole(\n            _deriveRootRole(manager),\n            adminRoleDescriptionHash\n        );\n    }\n\n    /// @notice Derives the whitelist expiration extender role for the specific\n    /// manager address\n    /// @param manager Manager address\n    /// @return whitelistExpirationExtenderRole Whitelist expiration extender\n    /// role\n    function _deriveWhitelistExpirationExtenderRole(address manager)\n        internal\n        view\n        returns (bytes32 whitelistExpirationExtenderRole)\n    {\n        whitelistExpirationExtenderRole = _deriveRole(\n            _deriveAdminRole(manager),\n            WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION_HASH\n        );\n    }\n\n    /// @notice Derives the whitelist expiration setter role for the specific\n    /// manager address\n    /// @param manager Manager address\n    /// @return whitelistExpirationSetterRole Whitelist expiration setter role\n    function _deriveWhitelistExpirationSetterRole(address manager)\n        internal\n        view\n        returns (bytes32 whitelistExpirationSetterRole)\n    {\n        whitelistExpirationSetterRole = _deriveRole(\n            _deriveAdminRole(manager),\n            WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION_HASH\n        );\n    }\n\n    /// @notice Derives the indefinite whitelister role for the specific\n    /// manager address\n    /// @param manager Manager address\n    /// @return indefiniteWhitelisterRole Indefinite whitelister role\n    function _deriveIndefiniteWhitelisterRole(address manager)\n        internal\n        view\n        returns (bytes32 indefiniteWhitelisterRole)\n    {\n        indefiniteWhitelisterRole = _deriveRole(\n            _deriveAdminRole(manager),\n            INDEFINITE_WHITELISTER_ROLE_DESCRIPTION_HASH\n        );\n    }\n}\n"
    },
    "contracts/access-control-registry/interfaces/IWhitelistRolesWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./IWhitelistRoles.sol\";\n\ninterface IWhitelistRolesWithManager is IWhitelistRoles {\n    function manager() external view returns (address);\n\n    function adminRole() external view returns (bytes32);\n\n    function whitelistExpirationExtenderRole() external view returns (bytes32);\n\n    function whitelistExpirationSetterRole() external view returns (bytes32);\n\n    function indefiniteWhitelisterRole() external view returns (bytes32);\n}\n"
    },
    "contracts/access-control-registry/RoleDeriver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\n/// @title Contract that implements the AccessControlRegistry role ID\n/// derivation logic\n/// @notice If a contract interfaces with AccessControlRegistry and needs to\n/// derive role IDs, it should inherit and use this contract instead of\n/// re-implementing the logic\ncontract RoleDeriver {\n    /// @notice Derives the root role of the manager\n    /// @param manager Manager address\n    /// @return rootRole Root role\n    function _deriveRootRole(address manager)\n        internal\n        pure\n        returns (bytes32 rootRole)\n    {\n        rootRole = keccak256(abi.encodePacked(manager));\n    }\n\n    /// @notice Derives the role using its admin role and description\n    /// @dev This implies that roles adminned by the same role cannot have the\n    /// same description\n    /// @param adminRole Admin role\n    /// @param description Description\n    /// @return role Role\n    function _deriveRole(bytes32 adminRole, string memory description)\n        internal\n        pure\n        returns (bytes32 role)\n    {\n        role = _deriveRole(adminRole, keccak256(abi.encodePacked(description)));\n    }\n\n    /// @notice Derives the role using its admin role and description hash\n    /// @dev This implies that roles adminned by the same role cannot have the\n    /// same description\n    /// @param adminRole Admin role\n    /// @param descriptionHash Description hash\n    /// @return role Role\n    function _deriveRole(bytes32 adminRole, bytes32 descriptionHash)\n        internal\n        pure\n        returns (bytes32 role)\n    {\n        role = keccak256(abi.encodePacked(adminRole, descriptionHash));\n    }\n}\n"
    },
    "contracts/access-control-registry/AccessControlClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./interfaces/IAccessControlClient.sol\";\n\ncontract AccessControlClient is IAccessControlClient {\n    /// @notice Address of the AccessControlRegistry contract that keeps the\n    /// roles\n    address public immutable override accessControlRegistry;\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    constructor(address _accessControlRegistry) {\n        require(_accessControlRegistry != address(0), \"ACR address zero\");\n        accessControlRegistry = _accessControlRegistry;\n    }\n}\n"
    },
    "contracts/access-control-registry/interfaces/IWhitelistRoles.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface IWhitelistRoles {\n    function adminRoleDescription() external view returns (string memory);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function INDEFINITE_WHITELISTER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n}\n"
    },
    "contracts/access-control-registry/interfaces/IAccessControlClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface IAccessControlClient {\n    function accessControlRegistry() external view returns (address);\n}\n"
    },
    "contracts/rrp/interfaces/IAirnodeRrp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./IAuthorizationUtils.sol\";\nimport \"./ITemplateUtils.sol\";\nimport \"./IWithdrawalUtils.sol\";\n\ninterface IAirnodeRrp is IAuthorizationUtils, ITemplateUtils, IWithdrawalUtils {\n    event SetSponsorshipStatus(\n        address indexed sponsor,\n        address indexed requester,\n        bool sponsorshipStatus\n    );\n\n    event MadeTemplateRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        uint256 requesterRequestCount,\n        uint256 chainId,\n        address requester,\n        bytes32 templateId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes parameters\n    );\n\n    event MadeFullRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        uint256 requesterRequestCount,\n        uint256 chainId,\n        address requester,\n        bytes32 endpointId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes parameters\n    );\n\n    event FulfilledRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        bytes data\n    );\n\n    event FailedRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        string errorMessage\n    );\n\n    function setSponsorshipStatus(address requester, bool sponsorshipStatus)\n        external;\n\n    function makeTemplateRequest(\n        bytes32 templateId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n    ) external returns (bytes32 requestId);\n\n    function makeFullRequest(\n        address airnode,\n        bytes32 endpointId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n    ) external returns (bytes32 requestId);\n\n    function fulfill(\n        bytes32 requestId,\n        address airnode,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata data,\n        bytes calldata signature\n    ) external returns (bool callSuccess, bytes memory callData);\n\n    function fail(\n        bytes32 requestId,\n        address airnode,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        string calldata errorMessage\n    ) external;\n\n    function sponsorToRequesterToSponsorshipStatus(\n        address sponsor,\n        address requester\n    ) external view returns (bool sponsorshipStatus);\n\n    function requesterToRequestCountPlusOne(address requester)\n        external\n        view\n        returns (uint256 requestCountPlusOne);\n\n    function requestIsAwaitingFulfillment(bytes32 requestId)\n        external\n        view\n        returns (bool isAwaitingFulfillment);\n}\n"
    },
    "contracts/rrp/interfaces/IAuthorizationUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface IAuthorizationUtils {\n    function checkAuthorizationStatus(\n        address[] calldata authorizers,\n        address airnode,\n        bytes32 requestId,\n        bytes32 endpointId,\n        address sponsor,\n        address requester\n    ) external view returns (bool status);\n\n    function checkAuthorizationStatuses(\n        address[] calldata authorizers,\n        address airnode,\n        bytes32[] calldata requestIds,\n        bytes32[] calldata endpointIds,\n        address[] calldata sponsors,\n        address[] calldata requesters\n    ) external view returns (bool[] memory statuses);\n}\n"
    },
    "contracts/rrp/interfaces/ITemplateUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface ITemplateUtils {\n    event CreatedTemplate(\n        bytes32 indexed templateId,\n        address airnode,\n        bytes32 endpointId,\n        bytes parameters\n    );\n\n    function createTemplate(\n        address airnode,\n        bytes32 endpointId,\n        bytes calldata parameters\n    ) external returns (bytes32 templateId);\n\n    function getTemplates(bytes32[] calldata templateIds)\n        external\n        view\n        returns (\n            address[] memory airnodes,\n            bytes32[] memory endpointIds,\n            bytes[] memory parameters\n        );\n\n    function templates(bytes32 templateId)\n        external\n        view\n        returns (\n            address airnode,\n            bytes32 endpointId,\n            bytes memory parameters\n        );\n}\n"
    },
    "contracts/rrp/interfaces/IWithdrawalUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface IWithdrawalUtils {\n    event RequestedWithdrawal(\n        address indexed airnode,\n        address indexed sponsor,\n        bytes32 indexed withdrawalRequestId,\n        address sponsorWallet\n    );\n\n    event FulfilledWithdrawal(\n        address indexed airnode,\n        address indexed sponsor,\n        bytes32 indexed withdrawalRequestId,\n        address sponsorWallet,\n        uint256 amount\n    );\n\n    function requestWithdrawal(address airnode, address sponsorWallet) external;\n\n    function fulfillWithdrawal(\n        bytes32 withdrawalRequestId,\n        address airnode,\n        address sponsor\n    ) external payable;\n\n    function sponsorToWithdrawalRequestCount(address sponsor)\n        external\n        view\n        returns (uint256 withdrawalRequestCount);\n}\n"
    },
    "contracts/rrp/requesters/RrpBeaconServerWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../access-control-registry/WhitelistRolesWithManager.sol\";\nimport \"./RrpBeaconServer.sol\";\nimport \"./interfaces/IRrpBeaconServerWithManager.sol\";\n\n/// @title RRP beacon server contract that a manager can use to temporarily or\n/// indefinitely whitelist readers for templates\ncontract RrpBeaconServerWithManager is\n    WhitelistRolesWithManager,\n    RrpBeaconServer,\n    IRrpBeaconServerWithManager\n{\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    /// @param _airnodeRrp Airnode RRP contract address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager,\n        address _airnodeRrp\n    )\n        WhitelistRolesWithManager(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager\n        )\n        RrpBeaconServer(_airnodeRrp)\n    {}\n\n    /// @notice Extends the expiration of the temporary whitelist of `reader`\n    /// to be able to read the beacon with `templateId` if the sender has the\n    /// whitelist expiration extender role\n    /// @param templateId Template ID\n    /// @param reader Reader address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function extendWhitelistExpiration(\n        bytes32 templateId,\n        address reader,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            manager == msg.sender ||\n                IAccessControlRegistry(accessControlRegistry).hasRole(\n                    whitelistExpirationExtenderRole,\n                    msg.sender\n                ),\n            \"Not expiration extender\"\n        );\n        _extendWhitelistExpirationAndEmit(\n            templateId,\n            reader,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the expiration of the temporary whitelist of `reader` to\n    /// be able to read the beacon with `templateId` if the sender has the\n    /// whitelist expiration extender role\n    /// @param templateId Template ID\n    /// @param reader Reader address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function setWhitelistExpiration(\n        bytes32 templateId,\n        address reader,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            manager == msg.sender ||\n                IAccessControlRegistry(accessControlRegistry).hasRole(\n                    whitelistExpirationSetterRole,\n                    msg.sender\n                ),\n            \"Not expiration setter\"\n        );\n        _setWhitelistExpirationAndEmit(templateId, reader, expirationTimestamp);\n    }\n\n    /// @notice Sets the indefinite whitelist status of `reader` to be able to\n    /// read the beacon with `templateId` if the sender has the indefinite\n    /// whitelister role\n    /// @param templateId Template ID\n    /// @param reader Reader address\n    /// @param status Indefinite whitelist status\n    function setIndefiniteWhitelistStatus(\n        bytes32 templateId,\n        address reader,\n        bool status\n    ) external override {\n        require(\n            manager == msg.sender ||\n                IAccessControlRegistry(accessControlRegistry).hasRole(\n                    indefiniteWhitelisterRole,\n                    msg.sender\n                ),\n            \"Not indefinite whitelister\"\n        );\n        _setIndefiniteWhitelistStatusAndEmit(templateId, reader, status);\n    }\n\n    /// @notice Revokes the indefinite whitelist status granted by a specific\n    /// account that no longer has the indefinite whitelister role\n    /// @param templateId Template ID\n    /// @param reader Reader address\n    /// @param setter Setter of the indefinite whitelist status\n    function revokeIndefiniteWhitelistStatus(\n        bytes32 templateId,\n        address reader,\n        address setter\n    ) external override {\n        require(\n            manager != setter &&\n                !IAccessControlRegistry(accessControlRegistry).hasRole(\n                    indefiniteWhitelisterRole,\n                    setter\n                ),\n            \"setter is indefinite whitelister\"\n        );\n        _revokeIndefiniteWhitelistStatusAndEmit(templateId, reader, setter);\n    }\n}\n"
    },
    "contracts/rrp/requesters/interfaces/IRrpBeaconServerWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./IRrpBeaconServer.sol\";\n\ninterface IRrpBeaconServerWithManager is IRrpBeaconServer {\n    function extendWhitelistExpiration(\n        bytes32 templateId,\n        address reader,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setWhitelistExpiration(\n        bytes32 templateId,\n        address reader,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setIndefiniteWhitelistStatus(\n        bytes32 templateId,\n        address reader,\n        bool status\n    ) external;\n\n    function revokeIndefiniteWhitelistStatus(\n        bytes32 templateId,\n        address reader,\n        address setter\n    ) external;\n}\n"
    },
    "contracts/rrp/authorizers/RequesterAuthorizerWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../access-control-registry/WhitelistRolesWithManager.sol\";\nimport \"./RequesterAuthorizer.sol\";\nimport \"./interfaces/IRequesterAuthorizerWithManager.sol\";\nimport \"../../access-control-registry/interfaces/IAccessControlRegistry.sol\";\n\n/// @title Authorizer contract that a manager can use to temporarily or\n/// indefinitely whitelist requesters for Airnode–endpoint pairs\n/// @notice The manager address here is expected to belong to an\n/// AccessControlAgent contract that is owned by the DAO\ncontract RequesterAuthorizerWithManager is\n    WhitelistRolesWithManager,\n    RequesterAuthorizer,\n    IRequesterAuthorizerWithManager\n{\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        WhitelistRolesWithManager(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager\n        )\n    {}\n\n    /// @notice Extends the expiration of the temporary whitelist of\n    /// `requester` for the `airnode`–`endpointId` pair if the sender has the\n    /// whitelist expiration extender role\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function extendWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            manager == msg.sender ||\n                IAccessControlRegistry(accessControlRegistry).hasRole(\n                    whitelistExpirationExtenderRole,\n                    msg.sender\n                ),\n            \"Not expiration extender\"\n        );\n        _extendWhitelistExpirationAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the expiration of the temporary whitelist of `requester`\n    /// for the `airnode`–`endpointId` pair if the sender has the whitelist\n    /// expiration setter role\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function setWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            manager == msg.sender ||\n                IAccessControlRegistry(accessControlRegistry).hasRole(\n                    whitelistExpirationSetterRole,\n                    msg.sender\n                ),\n            \"Not expiration setter\"\n        );\n        _setWhitelistExpirationAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the indefinite whitelist status of `requester` for the\n    /// `airnode`–`endpointId` pair if the sender has the indefinite\n    /// whitelister role\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param status Indefinite whitelist status\n    function setIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        bool status\n    ) external override {\n        require(\n            manager == msg.sender ||\n                IAccessControlRegistry(accessControlRegistry).hasRole(\n                    indefiniteWhitelisterRole,\n                    msg.sender\n                ),\n            \"Not indefinite whitelister\"\n        );\n        _setIndefiniteWhitelistStatusAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            status\n        );\n    }\n\n    /// @notice Revokes the indefinite whitelist status granted by a specific\n    /// account that no longer has the indefinite whitelister role\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param setter Setter of the indefinite whitelist status\n    function revokeIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        address setter\n    ) external override {\n        require(\n            manager != setter &&\n                !IAccessControlRegistry(accessControlRegistry).hasRole(\n                    indefiniteWhitelisterRole,\n                    setter\n                ),\n            \"setter is indefinite whitelister\"\n        );\n        _revokeIndefiniteWhitelistStatusAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            setter\n        );\n    }\n}\n"
    },
    "contracts/rrp/authorizers/RequesterAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../access-control-registry/Whitelist.sol\";\nimport \"./interfaces/IRequesterAuthorizer.sol\";\n\n/// @title Abstract contract that can be used to build Airnode authorizers that\n/// temporarily or permanently whitelist requesters for Airnode–endpoint pairs\nabstract contract RequesterAuthorizer is Whitelist, IRequesterAuthorizer {\n    /// @notice Extends the expiration of the temporary whitelist of\n    /// `requester` for the `airnode`–`endpointId` pair and emits an event\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function _extendWhitelistExpirationAndEmit(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) internal {\n        _extendWhitelistExpiration(\n            deriveServiceId(airnode, endpointId),\n            requester,\n            expirationTimestamp\n        );\n        emit ExtendedWhitelistExpiration(\n            airnode,\n            endpointId,\n            requester,\n            msg.sender,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the expiration of the temporary whitelist of `requester`\n    /// for the `airnode`–`endpointId` pair and emits an event\n    /// @dev Unlike `_extendWhitelistExpiration()`, this can hasten expiration.\n    /// Emits the event even if it does not change the state.\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function _setWhitelistExpirationAndEmit(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) internal {\n        _setWhitelistExpiration(\n            deriveServiceId(airnode, endpointId),\n            requester,\n            expirationTimestamp\n        );\n        emit SetWhitelistExpiration(\n            airnode,\n            endpointId,\n            requester,\n            msg.sender,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the indefinite whitelist status of `requester` for the\n    /// `airnode`–`endpointId` pair and emits an event\n    /// Emits the event even if it does not change the state.\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param status Indefinite whitelist status\n    function _setIndefiniteWhitelistStatusAndEmit(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        bool status\n    ) internal {\n        bytes32 serviceId = deriveServiceId(airnode, endpointId);\n        uint192 indefiniteWhitelistCount = _setIndefiniteWhitelistStatus(\n            serviceId,\n            requester,\n            status\n        );\n        emit SetIndefiniteWhitelistStatus(\n            airnode,\n            endpointId,\n            requester,\n            msg.sender,\n            status,\n            indefiniteWhitelistCount\n        );\n    }\n\n    /// @notice Revokes the indefinite whitelist status granted to `requester`\n    /// for the `airnode`–`endpointId` pair by a specific account and emits an\n    /// event\n    /// @dev Only emits the event if it changes the state\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param setter Setter of the indefinite whitelist status\n    function _revokeIndefiniteWhitelistStatusAndEmit(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        address setter\n    ) internal {\n        bytes32 serviceId = deriveServiceId(airnode, endpointId);\n        (\n            bool revoked,\n            uint192 indefiniteWhitelistCount\n        ) = _revokeIndefiniteWhitelistStatus(serviceId, requester, setter);\n        if (revoked) {\n            emit RevokedIndefiniteWhitelistStatus(\n                airnode,\n                endpointId,\n                requester,\n                setter,\n                msg.sender,\n                indefiniteWhitelistCount\n            );\n        }\n    }\n\n    /// @notice Returns if `requester` is whitelisted for the\n    /// `airnode`–`endpointId` pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @return isWhitelisted If `requester` is whitelisted for the\n    /// `airnode`–`endpointId` pair\n    function requesterIsWhitelisted(\n        address airnode,\n        bytes32 endpointId,\n        address requester\n    ) public view override returns (bool isWhitelisted) {\n        isWhitelisted = userIsWhitelisted(\n            deriveServiceId(airnode, endpointId),\n            requester\n        );\n    }\n\n    /// @notice Verifies the authorization status of a request\n    /// @dev This method has redundant arguments because all authorizer\n    /// contracts have to have the same interface and potential authorizer\n    /// contracts may require to access the arguments that are redundant here\n    /// @param requestId Request ID\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param sponsor Sponsor address\n    /// @param requester Requester address\n    /// @return Authorization status of the request\n    function isAuthorized(\n        bytes32 requestId, // solhint-disable-line no-unused-vars\n        address airnode,\n        bytes32 endpointId,\n        address sponsor, // solhint-disable-line no-unused-vars\n        address requester\n    ) external view override returns (bool) {\n        return requesterIsWhitelisted(airnode, endpointId, requester);\n    }\n\n    /// @notice Returns the whitelist status of `requester` for the\n    /// `airnode`–`endpointId` pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @return expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    /// @return indefiniteWhitelistCount Number of times `requester` was\n    /// whitelisted indefinitely for the `airnode`–`endpointId` pair\n    function airnodeToEndpointIdToRequesterToWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester\n    )\n        external\n        view\n        override\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount)\n    {\n        WhitelistStatus\n            storage whitelistStatus = serviceIdToUserToWhitelistStatus[\n                deriveServiceId(airnode, endpointId)\n            ][requester];\n        expirationTimestamp = whitelistStatus.expirationTimestamp;\n        indefiniteWhitelistCount = whitelistStatus.indefiniteWhitelistCount;\n    }\n\n    /// @notice Returns if an account has indefinitely whitelisted `requester`\n    /// for the `airnode`–`endpointId` pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param setter Address of the account that has potentially whitelisted\n    /// `requester` for the `airnode`–`endpointId` pair indefinitely\n    /// @return indefiniteWhitelistStatus If `setter` has indefinitely\n    /// whitelisted `requester` for the `airnode`–`endpointId` pair\n    function airnodeToEndpointIdToRequesterToSetterToIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        address setter\n    ) external view override returns (bool indefiniteWhitelistStatus) {\n        indefiniteWhitelistStatus = serviceIdToUserToSetterToIndefiniteWhitelistStatus[\n            deriveServiceId(airnode, endpointId)\n        ][requester][setter];\n    }\n\n    /// @notice Called privately to derive a service ID out of the Airnode\n    /// address and the endpoint ID\n    /// @dev This is done to re-use the more general Whitelist contract for\n    /// the specific case of Airnode–endpoint pairs\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @return serviceId Service ID\n    function deriveServiceId(address airnode, bytes32 endpointId)\n        private\n        pure\n        returns (bytes32 serviceId)\n    {\n        serviceId = keccak256(abi.encodePacked(airnode, endpointId));\n    }\n}\n"
    },
    "contracts/rrp/authorizers/interfaces/IRequesterAuthorizerWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../../access-control-registry/interfaces/IWhitelistRolesWithManager.sol\";\nimport \"./IRequesterAuthorizer.sol\";\n\ninterface IRequesterAuthorizerWithManager is\n    IWhitelistRolesWithManager,\n    IRequesterAuthorizer\n{}\n"
    },
    "contracts/rrp/authorizers/interfaces/IRequesterAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./IAuthorizer.sol\";\n\ninterface IRequesterAuthorizer is IAuthorizer {\n    event ExtendedWhitelistExpiration(\n        address indexed airnode,\n        bytes32 endpointId,\n        address indexed requester,\n        address indexed sender,\n        uint256 expiration\n    );\n\n    event SetWhitelistExpiration(\n        address indexed airnode,\n        bytes32 endpointId,\n        address indexed requester,\n        address indexed sender,\n        uint256 expiration\n    );\n\n    event SetIndefiniteWhitelistStatus(\n        address indexed airnode,\n        bytes32 endpointId,\n        address indexed requester,\n        address indexed sender,\n        bool status,\n        uint192 indefiniteWhitelistCount\n    );\n\n    event RevokedIndefiniteWhitelistStatus(\n        address indexed airnode,\n        bytes32 endpointId,\n        address indexed requester,\n        address indexed setter,\n        address sender,\n        uint192 indefiniteWhitelistCount\n    );\n\n    function extendWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        bool status\n    ) external;\n\n    function revokeIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        address setter\n    ) external;\n\n    function requesterIsWhitelisted(\n        address airnode,\n        bytes32 endpointId,\n        address requester\n    ) external view returns (bool isWhitelisted);\n\n    function airnodeToEndpointIdToRequesterToWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester\n    )\n        external\n        view\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount);\n\n    function airnodeToEndpointIdToRequesterToSetterToIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        address setter\n    ) external view returns (bool indefiniteWhitelistStatus);\n}\n"
    },
    "contracts/rrp/authorizers/interfaces/IAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface IAuthorizer {\n    function isAuthorized(\n        bytes32 requestId,\n        address airnode,\n        bytes32 endpointId,\n        address sponsor,\n        address requester\n    ) external view returns (bool);\n}\n"
    },
    "contracts/rrp/authorizers/RequesterAuthorizerWithAirnode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../access-control-registry/WhitelistRoles.sol\";\nimport \"./RequesterAuthorizer.sol\";\nimport \"./interfaces/IRequesterAuthorizerWithAirnode.sol\";\nimport \"../../access-control-registry/interfaces/IAccessControlRegistry.sol\";\n\n/// @title Authorizer contract that Airnodes can use to temporarily or\n/// indefinitely whitelist requesters for Airnode–endpoint pairs\ncontract RequesterAuthorizerWithAirnode is\n    WhitelistRoles,\n    RequesterAuthorizer,\n    IRequesterAuthorizerWithAirnode\n{\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription\n    ) WhitelistRoles(_accessControlRegistry, _adminRoleDescription) {}\n\n    /// @notice Extends the expiration of the temporary whitelist of\n    /// `requester` for the `airnode`–`endpointId` pair if the sender has the\n    /// whitelist expiration extender role\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function extendWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            airnode == msg.sender ||\n                IAccessControlRegistry(accessControlRegistry).hasRole(\n                    deriveWhitelistExpirationExtenderRole(airnode),\n                    msg.sender\n                ),\n            \"Not expiration extender\"\n        );\n        _extendWhitelistExpirationAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the expiration of the temporary whitelist of `requester`\n    /// for the `airnode`–`endpointId` pair if the sender has the whitelist\n    /// expiration setter role\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function setWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            airnode == msg.sender ||\n                IAccessControlRegistry(accessControlRegistry).hasRole(\n                    deriveWhitelistExpirationSetterRole(airnode),\n                    msg.sender\n                ),\n            \"Not expiration setter\"\n        );\n        _setWhitelistExpirationAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the indefinite whitelist status of `requester` for the\n    /// `airnode`–`endpointId` pair if the sender has the indefinite\n    /// whitelister role\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param status Indefinite whitelist status\n    function setIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        bool status\n    ) external override {\n        require(\n            airnode == msg.sender ||\n                IAccessControlRegistry(accessControlRegistry).hasRole(\n                    deriveIndefiniteWhitelisterRole(airnode),\n                    msg.sender\n                ),\n            \"Not indefinite whitelister\"\n        );\n        _setIndefiniteWhitelistStatusAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            status\n        );\n    }\n\n    /// @notice Revokes the indefinite whitelist status granted by a specific\n    /// account that no longer has the indefinite whitelister role\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param requester Requester address\n    /// @param setter Setter of the indefinite whitelist status\n    function revokeIndefiniteWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address requester,\n        address setter\n    ) external override {\n        require(\n            airnode != setter &&\n                !IAccessControlRegistry(accessControlRegistry).hasRole(\n                    deriveIndefiniteWhitelisterRole(airnode),\n                    setter\n                ),\n            \"setter is indefinite whitelister\"\n        );\n        _revokeIndefiniteWhitelistStatusAndEmit(\n            airnode,\n            endpointId,\n            requester,\n            setter\n        );\n    }\n\n    /// @notice Derives the admin role for the specific Airnode address\n    /// @param airnode Airnode address\n    /// @return adminRole Admin role\n    function deriveAdminRole(address airnode)\n        public\n        view\n        override\n        returns (bytes32 adminRole)\n    {\n        adminRole = _deriveAdminRole(airnode);\n    }\n\n    /// @notice Derives the whitelist expiration extender role for the specific\n    /// Airnode address\n    /// @param airnode Airnode address\n    /// @return whitelistExpirationExtenderRole Whitelist expiration extender\n    /// role\n    function deriveWhitelistExpirationExtenderRole(address airnode)\n        public\n        view\n        override\n        returns (bytes32 whitelistExpirationExtenderRole)\n    {\n        whitelistExpirationExtenderRole = _deriveWhitelistExpirationExtenderRole(\n            airnode\n        );\n    }\n\n    /// @notice Derives the whitelist expiration setter role for the specific\n    /// Airnode address\n    /// @param airnode Airnode address\n    /// @return whitelistExpirationSetterRole Whitelist expiration setter role\n    function deriveWhitelistExpirationSetterRole(address airnode)\n        public\n        view\n        override\n        returns (bytes32 whitelistExpirationSetterRole)\n    {\n        whitelistExpirationSetterRole = _deriveWhitelistExpirationSetterRole(\n            airnode\n        );\n    }\n\n    /// @notice Derives the indefinite whitelister role for the specific\n    /// Airnode address\n    /// @param airnode Airnode address\n    /// @return indefiniteWhitelisterRole Indefinite whitelister role\n    function deriveIndefiniteWhitelisterRole(address airnode)\n        public\n        view\n        override\n        returns (bytes32 indefiniteWhitelisterRole)\n    {\n        indefiniteWhitelisterRole = _deriveIndefiniteWhitelisterRole(airnode);\n    }\n}\n"
    },
    "contracts/rrp/authorizers/interfaces/IRequesterAuthorizerWithAirnode.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../../access-control-registry/interfaces/IWhitelistRoles.sol\";\nimport \"./IRequesterAuthorizer.sol\";\n\ninterface IRequesterAuthorizerWithAirnode is\n    IWhitelistRoles,\n    IRequesterAuthorizer\n{\n    function deriveAdminRole(address airnode)\n        external\n        view\n        returns (bytes32 role);\n\n    function deriveWhitelistExpirationExtenderRole(address airnode)\n        external\n        view\n        returns (bytes32 role);\n\n    function deriveWhitelistExpirationSetterRole(address airnode)\n        external\n        view\n        returns (bytes32 role);\n\n    function deriveIndefiniteWhitelisterRole(address airnode)\n        external\n        view\n        returns (bytes32 role);\n}\n"
    },
    "contracts/access-control-registry/AccessControlRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./RoleDeriver.sol\";\nimport \"./interfaces/IAccessControlRegistry.sol\";\n\n/// @title Contract that allows users to manage independent, tree-shaped access\n/// control tables\n/// @notice Multiple contracts can refer to this contract to check if their\n/// users have granted accounts with specific roles. Therefore, it aims to keep\n/// all access control roles of its users in this single contract.\n/// @dev Each user is called a \"manager\", and are the only member of their root\n/// role. Starting from this root role, one can create an arbitrary tree of\n/// roles and grant these to accounts. Each role has a description, and roles\n/// adminned by the same role cannot have the same description.\ncontract AccessControlRegistry is\n    AccessControl,\n    RoleDeriver,\n    IAccessControlRegistry\n{\n    /// @notice Initializes the manager by initializing its root role and\n    /// granting it to them\n    /// @dev Anyone can initialize a manager. An uninitialized manager\n    /// attempting to initialize a role will be initialized automatically.\n    /// Once a manager is initialized, subsequent initializations have no\n    /// effect.\n    /// @param manager Manager address to be initialized\n    function initializeManager(address manager) public override {\n        bytes32 rootRole = deriveRootRole(manager);\n        if (!hasRole(rootRole, manager)) {\n            _setupRole(rootRole, manager);\n            emit InitializedManager(manager, rootRole);\n        }\n    }\n\n    /// @notice Called for the account to renounce the role\n    /// @dev Overriden to disallow managers from renouncing their root roles\n    /// @param role Role to be renounced\n    /// @param account Account to renounce the role\n    function renounceRole(bytes32 role, address account)\n        public\n        override(AccessControl, IAccessControl)\n    {\n        require(\n            role != deriveRootRole(account),\n            \"role is root role of account\"\n        );\n        AccessControl.renounceRole(role, account);\n    }\n\n    /// @notice Initializes a role, which includes setting its admin,\n    /// associating it with its manager and granting it to the sender\n    /// @dev If the sender should not have the initialized role, they should\n    /// explicitly renounce it afterwards.\n    /// Once a role is initialized, subsequent initialization have no effect,\n    /// other than granting the role to the sender.\n    /// The sender must be a member of `adminRole`.\n    /// If the sender is an uninitialized manager that is initializing a role\n    /// directly under their root role, manager initialization will happen\n    /// automatically, which will grant the sender `adminRole`.\n    /// @param adminRole Admin role to be assigned to the initialized role\n    /// @param description Human-readable description of the initialized role\n    /// @return role Initialized role\n    function initializeRole(bytes32 adminRole, string calldata description)\n        public\n        override\n        returns (bytes32 role)\n    {\n        role = deriveRole(adminRole, description);\n        if (getRoleAdmin(role) == DEFAULT_ADMIN_ROLE) {\n            if (adminRole == deriveRootRole(_msgSender())) {\n                initializeManager(_msgSender());\n            }\n            _setRoleAdmin(role, adminRole);\n            emit InitializedRole(role, adminRole, description, _msgSender());\n        }\n        grantRole(role, _msgSender());\n    }\n\n    /// @notice Initializes roles and grants them to the respective accounts\n    /// @dev If a specific role should be initialized but not granted to an\n    /// account, the respective account parameter can be left as `address(0)`.\n    /// Lengths of the arguments must be equal, and less than 33.\n    /// @param adminRoles Admin role to be assigned to the initialized roles\n    /// @param descriptions Human-readable descriptions of the initialized\n    /// roles\n    /// @param accounts Accounts the initialized roles will be granted to\n    /// @return roles Initialized roles\n    function initializeAndGrantRoles(\n        bytes32[] calldata adminRoles,\n        string[] calldata descriptions,\n        address[] calldata accounts\n    ) external override returns (bytes32[] memory roles) {\n        uint256 argumentLength = adminRoles.length;\n        require(\n            argumentLength == descriptions.length &&\n                argumentLength == accounts.length,\n            \"Argument length mismatch\"\n        );\n        require(argumentLength <= 32, \"Arguments too long\");\n        roles = new bytes32[](argumentLength);\n        for (uint256 ind = 0; ind < argumentLength; ind++) {\n            roles[ind] = initializeRole(adminRoles[ind], descriptions[ind]);\n            if (accounts[ind] != address(0)) {\n                grantRole(roles[ind], accounts[ind]);\n            }\n        }\n    }\n\n    /// @notice Derives the root role of the manager\n    /// @param manager Manager address\n    /// @return rootRole Root role\n    function deriveRootRole(address manager)\n        public\n        pure\n        override\n        returns (bytes32 rootRole)\n    {\n        rootRole = _deriveRootRole(manager);\n    }\n\n    /// @notice Derives the role using its admin role and description\n    /// @dev This implies that roles adminned by the same role cannot have the\n    /// same description\n    /// @param adminRole Admin role\n    /// @param description Description\n    /// @return role Role\n    function deriveRole(bytes32 adminRole, string calldata description)\n        public\n        pure\n        override\n        returns (bytes32 role)\n    {\n        role = _deriveRole(adminRole, description);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/rrp/authorizers/mock/MockApi3Token.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockApi3Token is ERC20 {\n    constructor() ERC20(\"API3\", \"API3\") {\n        _mint(msg.sender, 100e6 ether);\n    }\n}\n"
    },
    "contracts/rrp/WithdrawalUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./interfaces/IWithdrawalUtils.sol\";\n\n/// @title Contract that implements logic for withdrawals from sponsor wallets\ncontract WithdrawalUtils is IWithdrawalUtils {\n    /// @notice Called to get the withdrawal request count of the sponsor\n    /// @dev Can be used to calculate the ID of the next withdrawal request the\n    /// sponsor will make\n    mapping(address => uint256) public override sponsorToWithdrawalRequestCount;\n\n    /// @dev Hash of expected fulfillment parameters are kept to verify that\n    /// the fulfillment will be done with the correct parameters\n    mapping(bytes32 => bytes32) private withdrawalRequestIdToParameters;\n\n    /// @notice Called by a sponsor to create a request for the Airnode to send\n    /// the funds kept in the respective sponsor wallet to the sponsor\n    /// @dev We do not need to use the withdrawal request parameters in the\n    /// request ID hash to validate them at the node-side because all of the\n    /// parameters are used during fulfillment and will get validated on-chain.\n    /// The first withdrawal request a sponsor will make will cost slightly\n    /// higher gas than the rest due to how the request counter is implemented.\n    /// @param airnode Airnode address\n    /// @param sponsorWallet Sponsor wallet that the withdrawal is requested\n    /// from\n    function requestWithdrawal(address airnode, address sponsorWallet)\n        external\n        override\n    {\n        bytes32 withdrawalRequestId = keccak256(\n            abi.encodePacked(\n                block.chainid,\n                address(this),\n                msg.sender,\n                ++sponsorToWithdrawalRequestCount[msg.sender]\n            )\n        );\n        withdrawalRequestIdToParameters[withdrawalRequestId] = keccak256(\n            abi.encodePacked(airnode, msg.sender, sponsorWallet)\n        );\n        emit RequestedWithdrawal(\n            airnode,\n            msg.sender,\n            withdrawalRequestId,\n            sponsorWallet\n        );\n    }\n\n    /// @notice Called by the Airnode using the sponsor wallet to fulfill the\n    /// withdrawal request made by the sponsor\n    /// @dev The Airnode sends the funds to the sponsor through this method\n    /// to emit an event that indicates that the withdrawal request has been\n    /// fulfilled\n    /// @param withdrawalRequestId Withdrawal request ID\n    /// @param airnode Airnode address\n    /// @param sponsor Sponsor address\n    function fulfillWithdrawal(\n        bytes32 withdrawalRequestId,\n        address airnode,\n        address sponsor\n    ) external payable override {\n        require(\n            withdrawalRequestIdToParameters[withdrawalRequestId] ==\n                keccak256(abi.encodePacked(airnode, sponsor, msg.sender)),\n            \"Invalid withdrawal fulfillment\"\n        );\n        delete withdrawalRequestIdToParameters[withdrawalRequestId];\n        emit FulfilledWithdrawal(\n            airnode,\n            sponsor,\n            withdrawalRequestId,\n            msg.sender,\n            msg.value\n        );\n        (bool success, ) = sponsor.call{value: msg.value}(\"\"); // solhint-disable-line avoid-low-level-calls\n        require(success, \"Transfer failed\");\n    }\n}\n"
    },
    "contracts/rrp/AirnodeRrp.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"./AuthorizationUtils.sol\";\nimport \"./TemplateUtils.sol\";\nimport \"./WithdrawalUtils.sol\";\nimport \"./interfaces/IAirnodeRrp.sol\";\n\n/// @title Contract that implements the Airnode request–response protocol (RRP)\ncontract AirnodeRrp is\n    AuthorizationUtils,\n    TemplateUtils,\n    WithdrawalUtils,\n    IAirnodeRrp\n{\n    using ECDSA for bytes32;\n\n    /// @notice Called to get the sponsorship status for a sponsor–requester\n    /// pair\n    mapping(address => mapping(address => bool))\n        public\n        override sponsorToRequesterToSponsorshipStatus;\n\n    /// @notice Called to get the request count of the requester plus one\n    /// @dev Can be used to calculate the ID of the next request the requester\n    /// will make\n    mapping(address => uint256) public override requesterToRequestCountPlusOne;\n\n    /// @dev Hash of expected fulfillment parameters are kept to verify that\n    /// the fulfillment will be done with the correct parameters. This value is\n    /// also used to check if the fulfillment for the particular request is\n    /// expected (i.e., if there are recorded fulfillment parameters)\n    mapping(bytes32 => bytes32) private requestIdToFulfillmentParameters;\n\n    /// @notice Called by the sponsor to set the sponsorship status of a\n    /// requester, i.e., allow or disallow a requester to make requests that\n    /// will be fulfilled by the sponsor wallet\n    /// @dev This is not Airnode-specific, i.e., the sponsor allows the\n    /// requester's requests to be fulfilled through its sponsor wallets across\n    /// all Airnodes\n    /// @param requester Requester address\n    /// @param sponsorshipStatus Sponsorship status\n    function setSponsorshipStatus(address requester, bool sponsorshipStatus)\n        external\n        override\n    {\n        // Initialize the requester request count for consistent request gas\n        // cost\n        if (requesterToRequestCountPlusOne[requester] == 0) {\n            requesterToRequestCountPlusOne[requester] = 1;\n        }\n        sponsorToRequesterToSponsorshipStatus[msg.sender][\n            requester\n        ] = sponsorshipStatus;\n        emit SetSponsorshipStatus(msg.sender, requester, sponsorshipStatus);\n    }\n\n    /// @notice Called by the requester to make a request that refers to a\n    /// template for the Airnode address, endpoint ID and parameters\n    /// @dev `fulfillAddress` is not allowed to be the address of this\n    /// contract. This is not actually needed to protect users that use the\n    /// protocol as intended, but it is done for good measure.\n    /// @param templateId Template ID\n    /// @param sponsor Sponsor address\n    /// @param sponsorWallet Sponsor wallet that is requested to fulfill the\n    /// request\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param parameters Parameters provided by the requester in addition to\n    /// the parameters in the template\n    /// @return requestId Request ID\n    function makeTemplateRequest(\n        bytes32 templateId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n    ) external override returns (bytes32 requestId) {\n        address airnode = templates[templateId].airnode;\n        // If the Airnode address of the template is zero the template does not\n        // exist because template creation does not allow zero Airnode address\n        require(airnode != address(0), \"Template does not exist\");\n        require(fulfillAddress != address(this), \"Fulfill address AirnodeRrp\");\n        require(\n            sponsorToRequesterToSponsorshipStatus[sponsor][msg.sender],\n            \"Requester not sponsored\"\n        );\n        uint256 requesterRequestCount = requesterToRequestCountPlusOne[\n            msg.sender\n        ];\n        requestId = keccak256(\n            abi.encodePacked(\n                block.chainid,\n                address(this),\n                msg.sender,\n                requesterRequestCount,\n                templateId,\n                sponsor,\n                sponsorWallet,\n                fulfillAddress,\n                fulfillFunctionId,\n                parameters\n            )\n        );\n        requestIdToFulfillmentParameters[requestId] = keccak256(\n            abi.encodePacked(\n                airnode,\n                sponsorWallet,\n                fulfillAddress,\n                fulfillFunctionId\n            )\n        );\n        requesterToRequestCountPlusOne[msg.sender]++;\n        emit MadeTemplateRequest(\n            airnode,\n            requestId,\n            requesterRequestCount,\n            block.chainid,\n            msg.sender,\n            templateId,\n            sponsor,\n            sponsorWallet,\n            fulfillAddress,\n            fulfillFunctionId,\n            parameters\n        );\n    }\n\n    /// @notice Called by the requester to make a full request, which provides\n    /// all of its parameters as arguments and does not refer to a template\n    /// @dev `fulfillAddress` is not allowed to be the address of this\n    /// contract. This is not actually needed to protect users that use the\n    /// protocol as intended, but it is done for good measure.\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\n    /// @param sponsor Sponsor address\n    /// @param sponsorWallet Sponsor wallet that is requested to fulfill\n    /// the request\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param parameters All request parameters\n    /// @return requestId Request ID\n    function makeFullRequest(\n        address airnode,\n        bytes32 endpointId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n    ) external override returns (bytes32 requestId) {\n        require(airnode != address(0), \"Airnode address zero\");\n        require(fulfillAddress != address(this), \"Fulfill address AirnodeRrp\");\n        require(\n            sponsorToRequesterToSponsorshipStatus[sponsor][msg.sender],\n            \"Requester not sponsored\"\n        );\n        uint256 requesterRequestCount = requesterToRequestCountPlusOne[\n            msg.sender\n        ];\n        requestId = keccak256(\n            abi.encodePacked(\n                block.chainid,\n                address(this),\n                msg.sender,\n                requesterRequestCount,\n                airnode,\n                endpointId,\n                sponsor,\n                sponsorWallet,\n                fulfillAddress,\n                fulfillFunctionId,\n                parameters\n            )\n        );\n        requestIdToFulfillmentParameters[requestId] = keccak256(\n            abi.encodePacked(\n                airnode,\n                sponsorWallet,\n                fulfillAddress,\n                fulfillFunctionId\n            )\n        );\n        requesterToRequestCountPlusOne[msg.sender]++;\n        emit MadeFullRequest(\n            airnode,\n            requestId,\n            requesterRequestCount,\n            block.chainid,\n            msg.sender,\n            endpointId,\n            sponsor,\n            sponsorWallet,\n            fulfillAddress,\n            fulfillFunctionId,\n            parameters\n        );\n    }\n\n    /// @notice Called by Airnode to fulfill the request (template or full)\n    /// @dev The data is ABI-encoded as a `bytes` type, with its format\n    /// depending on the request specifications.\n    /// This will not revert depending on the external call. However, it will\n    /// return `false` if the external call reverts or if there is no function\n    /// with a matching signature at `fulfillAddress`. On the other hand, it\n    /// will return `true` if the external call returns successfully or if\n    /// there is no contract deployed at `fulfillAddress`.\n    /// If `callSuccess` is `false`, `callData` can be decoded to retrieve the\n    /// revert string.\n    /// @param requestId Request ID\n    /// @param airnode Airnode address\n    /// @param data Fulfillment data\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @return callSuccess If the fulfillment call succeeded\n    /// @return callData Data returned by the fulfillment call (if there is\n    /// any)\n    function fulfill(\n        bytes32 requestId,\n        address airnode,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata data,\n        bytes calldata signature\n    ) external override returns (bool callSuccess, bytes memory callData) {\n        require(\n            keccak256(\n                abi.encodePacked(\n                    airnode,\n                    msg.sender,\n                    fulfillAddress,\n                    fulfillFunctionId\n                )\n            ) == requestIdToFulfillmentParameters[requestId],\n            \"Invalid request fulfillment\"\n        );\n        require(\n            (\n                keccak256(abi.encodePacked(requestId, data))\n                    .toEthSignedMessageHash()\n            ).recover(signature) == airnode,\n            \"Invalid signature\"\n        );\n        delete requestIdToFulfillmentParameters[requestId];\n        (callSuccess, callData) = fulfillAddress.call( // solhint-disable-line avoid-low-level-calls\n            abi.encodeWithSelector(fulfillFunctionId, requestId, data)\n        );\n        if (callSuccess) {\n            emit FulfilledRequest(airnode, requestId, data);\n        } else {\n            // We do not bubble up the revert string from `callData`\n            emit FailedRequest(\n                airnode,\n                requestId,\n                \"Fulfillment failed unexpectedly\"\n            );\n        }\n    }\n\n    /// @notice Called by Airnode if the request cannot be fulfilled\n    /// @dev Airnode should fall back to this if a request cannot be fulfilled\n    /// because static call to `fulfill()` returns `false` for `callSuccess`\n    /// @param requestId Request ID\n    /// @param airnode Airnode address\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param errorMessage A message that explains why the request has failed\n    function fail(\n        bytes32 requestId,\n        address airnode,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        string calldata errorMessage\n    ) external override {\n        require(\n            keccak256(\n                abi.encodePacked(\n                    airnode,\n                    msg.sender,\n                    fulfillAddress,\n                    fulfillFunctionId\n                )\n            ) == requestIdToFulfillmentParameters[requestId],\n            \"Invalid request fulfillment\"\n        );\n        delete requestIdToFulfillmentParameters[requestId];\n        emit FailedRequest(airnode, requestId, errorMessage);\n    }\n\n    /// @notice Called to check if the request with the ID is made but not\n    /// fulfilled/failed yet\n    /// @dev If a requester has made a request, received a request ID but did\n    /// not hear back, it can call this method to check if the Airnode has\n    /// called back `fail()` instead.\n    /// @param requestId Request ID\n    /// @return isAwaitingFulfillment If the request is awaiting fulfillment\n    /// (i.e., `true` if `fulfill()` or `fail()` is not called back yet,\n    /// `false` otherwise)\n    function requestIsAwaitingFulfillment(bytes32 requestId)\n        external\n        view\n        override\n        returns (bool isAwaitingFulfillment)\n    {\n        isAwaitingFulfillment =\n            requestIdToFulfillmentParameters[requestId] != bytes32(0);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/rrp/AuthorizationUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./interfaces/IAuthorizationUtils.sol\";\nimport \"./authorizers/interfaces/IRrpAuthorizer.sol\";\n\n/// @title Contract that implements authorization checks\ncontract AuthorizationUtils is IAuthorizationUtils {\n    /// @notice Uses the authorizer contracts of an Airnode to decide if a\n    /// request is authorized. Once an Airnode receives a request, it calls\n    /// this method to determine if it should respond. Similarly, third parties\n    /// can use this method to determine if a particular request would be\n    /// authorized.\n    /// @dev This method is meant to be called off-chain, statically by the\n    /// Airnode to decide if it should respond to a request. The requester can\n    /// also call it, yet this function returning true should not be taken as a\n    /// guarantee of the subsequent request being fulfilled.\n    /// It is enough for only one of the authorizer contracts to return true\n    /// for the request to be authorized.\n    /// @param authorizers Authorizer contract addresses\n    /// @param airnode Airnode address\n    /// @param requestId Request ID\n    /// @param endpointId Endpoint ID\n    /// @param sponsor Sponsor address\n    /// @param requester Requester address\n    /// @return status Authorization status of the request\n    function checkAuthorizationStatus(\n        address[] calldata authorizers,\n        address airnode,\n        bytes32 requestId,\n        bytes32 endpointId,\n        address sponsor,\n        address requester\n    ) public view override returns (bool status) {\n        for (uint256 ind = 0; ind < authorizers.length; ind++) {\n            IRrpAuthorizer authorizer = IRrpAuthorizer(authorizers[ind]);\n            if (\n                authorizer.isAuthorized(\n                    requestId,\n                    airnode,\n                    endpointId,\n                    sponsor,\n                    requester\n                )\n            ) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// @notice A convenience function to make multiple authorization status\n    /// checks with a single call\n    /// @param authorizers Authorizer contract addresses\n    /// @param airnode Airnode address\n    /// @param requestIds Request IDs\n    /// @param endpointIds Endpoint IDs\n    /// @param sponsors Sponsor addresses\n    /// @param requesters Requester addresses\n    /// @return statuses Authorization statuses of the request\n    function checkAuthorizationStatuses(\n        address[] calldata authorizers,\n        address airnode,\n        bytes32[] calldata requestIds,\n        bytes32[] calldata endpointIds,\n        address[] calldata sponsors,\n        address[] calldata requesters\n    ) external view override returns (bool[] memory statuses) {\n        require(\n            requestIds.length == endpointIds.length &&\n                requestIds.length == sponsors.length &&\n                requestIds.length == requesters.length,\n            \"Unequal parameter lengths\"\n        );\n        statuses = new bool[](requestIds.length);\n        for (uint256 ind = 0; ind < requestIds.length; ind++) {\n            statuses[ind] = checkAuthorizationStatus(\n                authorizers,\n                airnode,\n                requestIds[ind],\n                endpointIds[ind],\n                sponsors[ind],\n                requesters[ind]\n            );\n        }\n    }\n}\n"
    },
    "contracts/rrp/TemplateUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./interfaces/ITemplateUtils.sol\";\n\n/// @title Contract that implements request templates\ncontract TemplateUtils is ITemplateUtils {\n    struct Template {\n        address airnode;\n        bytes32 endpointId;\n        bytes parameters;\n    }\n\n    /// @notice Called to get a template\n    mapping(bytes32 => Template) public override templates;\n\n    /// @notice Creates a request template with the given parameters,\n    /// addressable by the ID it returns\n    /// @dev A specific set of request parameters will always have the same\n    /// template ID. This means a few things: (1) You can compute the expected\n    /// ID of a template before creating it, (2) Creating a new template with\n    /// the same parameters will overwrite the old one and return the same ID,\n    /// (3) After you query a template with its ID, you can verify its\n    /// integrity by applying the hash and comparing the result with the ID.\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\n    /// @param parameters Static request parameters (i.e., parameters that will\n    /// not change between requests, unlike the dynamic parameters determined\n    /// at request-time)\n    /// @return templateId Request template ID\n    function createTemplate(\n        address airnode,\n        bytes32 endpointId,\n        bytes calldata parameters\n    ) external override returns (bytes32 templateId) {\n        require(airnode != address(0), \"Airnode address zero\");\n        templateId = keccak256(\n            abi.encodePacked(airnode, endpointId, parameters)\n        );\n        templates[templateId] = Template({\n            airnode: airnode,\n            endpointId: endpointId,\n            parameters: parameters\n        });\n        emit CreatedTemplate(templateId, airnode, endpointId, parameters);\n    }\n\n    /// @notice A convenience method to retrieve multiple templates with a\n    /// single call\n    /// @dev Does not revert if the templates being indexed do not exist\n    /// @param templateIds Request template IDs\n    /// @return airnodes Array of Airnode addresses\n    /// @return endpointIds Array of endpoint IDs\n    /// @return parameters Array of request parameters\n    function getTemplates(bytes32[] calldata templateIds)\n        external\n        view\n        override\n        returns (\n            address[] memory airnodes,\n            bytes32[] memory endpointIds,\n            bytes[] memory parameters\n        )\n    {\n        airnodes = new address[](templateIds.length);\n        endpointIds = new bytes32[](templateIds.length);\n        parameters = new bytes[](templateIds.length);\n        for (uint256 ind = 0; ind < templateIds.length; ind++) {\n            Template storage template = templates[templateIds[ind]];\n            airnodes[ind] = template.airnode;\n            endpointIds[ind] = template.endpointId;\n            parameters[ind] = template.parameters;\n        }\n    }\n}\n"
    },
    "contracts/rrp/authorizers/interfaces/IRrpAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface IRrpAuthorizer {\n    // solhint-disable-next-line func-name-mixedcase\n    function AUTHORIZER_TYPE() external view returns (uint256);\n\n    function isAuthorized(\n        bytes32 requestId,\n        address airnode,\n        bytes32 endpointId,\n        address sponsor,\n        address requester\n    ) external view returns (bool);\n}\n"
    },
    "contracts/rrp/authorizers/mock/MockRrpAuthorizerAlwaysTrue.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../interfaces/IRrpAuthorizer.sol\";\n\n/// @title A mock authorizer that always returns true\ncontract MockRrpAuthorizerAlwaysTrue is IRrpAuthorizer {\n    uint256 public constant override AUTHORIZER_TYPE = 333;\n\n    function isAuthorized(\n        bytes32 requestId, // solhint-disable-line\n        address airnode, // solhint-disable-line\n        bytes32 endpointId, // solhint-disable-line\n        address sponsor, // solhint-disable-line\n        address requester // solhint-disable-line\n    ) external view virtual override returns (bool status) {\n        status = true;\n    }\n}\n"
    },
    "contracts/rrp/authorizers/mock/MockRrpAuthorizerAlwaysFalse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../interfaces/IRrpAuthorizer.sol\";\n\n/// @title A mock authorizer that always returns false\ncontract MockRrpAuthorizerAlwaysFalse is IRrpAuthorizer {\n    uint256 public constant override AUTHORIZER_TYPE = 333;\n\n    function isAuthorized(\n        bytes32 requestId, // solhint-disable-line\n        address airnode, // solhint-disable-line\n        bytes32 endpointId, // solhint-disable-line\n        address sponsor, // solhint-disable-line\n        address requester // solhint-disable-line\n    ) external view virtual override returns (bool status) {\n        status = false;\n    }\n}\n"
    },
    "contracts/rrp/authorizers/interfaces/IRequesterRrpAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./IRrpAuthorizer.sol\";\n\ninterface IRequesterRrpAuthorizer is IRrpAuthorizer {\n    event ExtendedWhitelistExpiration(\n        address indexed airnode,\n        bytes32 endpointId,\n        address indexed user,\n        address indexed admin,\n        uint256 expiration\n    );\n\n    event SetWhitelistExpiration(\n        address indexed airnode,\n        bytes32 endpointId,\n        address indexed user,\n        address indexed admin,\n        uint256 expiration\n    );\n\n    event SetWhitelistStatusPastExpiration(\n        address indexed airnode,\n        bytes32 endpointId,\n        address indexed user,\n        address indexed admin,\n        bool status\n    );\n\n    function extendWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setWhitelistStatusPastExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        bool status\n    ) external;\n\n    function userIsWhitelisted(\n        address airnode,\n        bytes32 endpointId,\n        address user\n    ) external view returns (bool isWhitelisted);\n\n    function airnodeToEndpointIdToUserToWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address user\n    )\n        external\n        view\n        returns (uint64 expirationTimestamp, bool whitelistedPastExpiration);\n}\n"
    },
    "contracts/rrp/authorizers/interfaces/IDaoRequesterRrpAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../../adminnable/interfaces/IAdminnable.sol\";\nimport \"./IRequesterRrpAuthorizer.sol\";\n\ninterface IDaoRequesterRrpAuthorizer is IAdminnable, IRequesterRrpAuthorizer {}\n"
    },
    "contracts/adminnable/interfaces/IAdminnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface IAdminnable {\n    event TransferredMetaAdminStatus(address indexed metaAdmin);\n\n    event SetRank(\n        address indexed callerAdmin,\n        address indexed targetAdmin,\n        uint256 newRank\n    );\n\n    event DecreasedSelfRank(address indexed admin, uint256 newRank);\n\n    function transferMetaAdminStatus(address metaAdmin_) external;\n\n    function setRank(address targetAdmin, uint256 newRank) external;\n\n    function decreaseSelfRank(uint256 newRank) external;\n\n    function metaAdmin() external view returns (address);\n\n    function adminToRank(address admin) external view returns (uint256);\n}\n"
    },
    "contracts/adminnable/Adminnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./interfaces/IAdminnable.sol\";\n\n/// @title Contract that implements multiple levels of admins\ncontract Adminnable is IAdminnable {\n    /// @notice Meta-admin ranks higher than all admins\n    address public override metaAdmin;\n\n    /// @notice Called to get the rank of an admin\n    /// @dev Higher ranks have more authority\n    mapping(address => uint256) public override adminToRank;\n\n    /// @dev Reverts if the caller's rank is not greater than or equal to\n    /// `rank`. `metaAdmin` always satisfies rank requirements.\n    /// @param rank Rank caller's rank will be compared to\n    modifier onlyWithRank(uint256 rank) {\n        require(\n            adminToRank[msg.sender] >= rank || msg.sender == metaAdmin,\n            \"Caller ranked low\"\n        );\n        _;\n    }\n\n    /// @dev Deployer needs to transfer meta-adminship afterwards\n    constructor() {\n        metaAdmin = msg.sender;\n    }\n\n    /// @notice Called by the meta-admin to transfer its status to another\n    /// address\n    /// @param metaAdmin_ New meta-admin\n    function transferMetaAdminStatus(address metaAdmin_) external override {\n        require(msg.sender == metaAdmin, \"Caller not metaAdmin\");\n        require(metaAdmin_ != address(0), \"Zero address\");\n        metaAdmin = metaAdmin_;\n        emit TransferredMetaAdminStatus(metaAdmin_);\n    }\n\n    /// @notice Called by an admin of higher rank to set the rank of an admin\n    /// of lower rank\n    /// @dev Reverts if `newRank` is `type(uint256).max`\n    /// @param targetAdmin Target admin address\n    /// @param newRank Rank to be set\n    function setRank(address targetAdmin, uint256 newRank)\n        external\n        override\n        onlyWithRank(max(adminToRank[targetAdmin], newRank) + 1)\n    {\n        require(targetAdmin != address(0), \"Target admin zero\");\n        adminToRank[targetAdmin] = newRank;\n        emit SetRank(msg.sender, targetAdmin, newRank);\n    }\n\n    /// @notice Called by an admin to decrease its rank\n    /// @dev Reverts if `newRank` is `type(uint256).max`\n    /// @param newRank Rank to be set\n    function decreaseSelfRank(uint256 newRank)\n        external\n        override\n        onlyWithRank(newRank + 1)\n    {\n        adminToRank[msg.sender] = newRank;\n        emit DecreasedSelfRank(msg.sender, newRank);\n    }\n\n    /// @notice Called internally to compute the maximum between two unsigned\n    /// integers\n    /// @param a First unsigned integer\n    /// @param b Second unsigned integer\n    /// @return Larger of the two unsigned integers\n    function max(uint256 a, uint256 b) private pure returns (uint256) {\n        return a > b ? a : b;\n    }\n}\n"
    },
    "contracts/rrp/authorizers/DaoRequesterRrpAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../adminnable/Adminnable.sol\";\nimport \"./RequesterRrpAuthorizer.sol\";\nimport \"./interfaces/IDaoRequesterRrpAuthorizer.sol\";\n\n/// @title Authorizer contract that whitelists requesters where the API3 DAO is\n/// the meta-admin\n/// @dev The meta-admin and the admins are also authorized even if they\n/// are not whitelisted explicitly\ncontract DaoRequesterRrpAuthorizer is\n    Adminnable,\n    RequesterRrpAuthorizer,\n    IDaoRequesterRrpAuthorizer\n{\n    enum AdminRank {\n        Unauthorized,\n        Admin,\n        SuperAdmin\n    }\n\n    /// @notice Authorizer contracts use `AUTHORIZER_TYPE` to signal their type\n    uint256 public constant override AUTHORIZER_TYPE = 2;\n\n    /// @notice Called by an admin to extend the whitelist expiration of a user\n    /// for the Airnode–endpoint pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the user will no longer\n    /// be whitelisted\n    function extendWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        uint64 expirationTimestamp\n    ) external override onlyWithRank(uint256(AdminRank.Admin)) {\n        extendWhitelistExpiration_(\n            airnode,\n            endpointId,\n            user,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Called by a super admin to set the whitelisting expiration of a\n    /// user for the Airnode–endpoint pair\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the whitelisting of the\n    /// user will expire\n    function setWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        uint64 expirationTimestamp\n    ) external override onlyWithRank(uint256(AdminRank.SuperAdmin)) {\n        setWhitelistExpiration_(airnode, endpointId, user, expirationTimestamp);\n    }\n\n    /// @notice Called by a super admin to set the whitelist status of a user\n    /// past expiration for the Airnode–endpoint pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @param status Whitelist status that the user will have past expiration\n    function setWhitelistStatusPastExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        bool status\n    ) external override onlyWithRank(uint256(AdminRank.SuperAdmin)) {\n        setWhitelistStatusPastExpiration_(airnode, endpointId, user, status);\n    }\n\n    /// @notice Verifies the authorization status of a request\n    /// @dev This method has redundant arguments because all authorizer\n    /// contracts have to have the same interface and potential authorizer\n    /// contracts may require to access the arguments that are redundant here\n    /// @param requestId Request ID\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param sponsor Sponsor address\n    /// @param requester Requester address\n    /// @return Authorization status of the request\n    function isAuthorized(\n        bytes32 requestId, // solhint-disable-line no-unused-vars\n        address airnode,\n        bytes32 endpointId,\n        address sponsor, // solhint-disable-line no-unused-vars\n        address requester\n    ) external view override returns (bool) {\n        return\n            userIsWhitelisted(\n                deriveServiceId(airnode, endpointId),\n                requester\n            ) ||\n            adminToRank[requester] >= uint256(AdminRank.Admin) ||\n            requester == metaAdmin;\n    }\n}\n"
    },
    "contracts/rrp/authorizers/RequesterRrpAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../adminnable/Whitelister.sol\";\nimport \"./interfaces/IRequesterRrpAuthorizer.sol\";\n\n/// @title Authorizer contract where requesters are whitelisted until an\n/// expiration time or indefinitely\nabstract contract RequesterRrpAuthorizer is\n    Whitelister,\n    IRequesterRrpAuthorizer\n{\n    /// @notice Called to check if a user is whitelisted to use the\n    /// Airnode–endpoint pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @return isWhitelisted If the user is whitelisted\n    function userIsWhitelisted(\n        address airnode,\n        bytes32 endpointId,\n        address user\n    ) external view override returns (bool isWhitelisted) {\n        return userIsWhitelisted(deriveServiceId(airnode, endpointId), user);\n    }\n\n    /// @notice Called to get the detailed whitelist status of a user for the\n    /// Airnode–endpoint pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @return expirationTimestamp Timestamp at which the whitelisting of the\n    /// user will expire\n    /// @return whitelistedPastExpiration Whitelist status that the user will\n    /// have past expiration\n    function airnodeToEndpointIdToUserToWhitelistStatus(\n        address airnode,\n        bytes32 endpointId,\n        address user\n    )\n        external\n        view\n        override\n        returns (uint64 expirationTimestamp, bool whitelistedPastExpiration)\n    {\n        WhitelistStatus\n            storage whitelistStatus = serviceIdToUserToWhitelistStatus[\n                deriveServiceId(airnode, endpointId)\n            ][user];\n        expirationTimestamp = whitelistStatus.expirationTimestamp;\n        whitelistedPastExpiration = whitelistStatus.whitelistedPastExpiration;\n    }\n\n    /// @notice Called internally to derive the service ID of the\n    /// Airnode–endpoint pair\n    /// @dev Whitelister contract that this contract inherits keeps whitelist\n    /// statuses in a single level hash map. We have two parameters here\n    /// (Airnode address and endpoint ID) from which we need to derive a single\n    /// service ID, and we do this by calculating their hash.\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @return serviceId Service ID\n    function deriveServiceId(address airnode, bytes32 endpointId)\n        internal\n        pure\n        returns (bytes32 serviceId)\n    {\n        require(airnode != address(0), \"Airnode address zero\");\n        return keccak256(abi.encodePacked(airnode, endpointId));\n    }\n\n    /// @notice Called internally to extend the whitelist expiration of a user\n    /// for the Airnode–endpoint pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the user will no longer\n    /// be whitelisted\n    function extendWhitelistExpiration_(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        uint64 expirationTimestamp\n    )\n        internal\n        onlyIfTimestampExtends(\n            deriveServiceId(airnode, endpointId),\n            user,\n            expirationTimestamp\n        )\n    {\n        serviceIdToUserToWhitelistStatus[deriveServiceId(airnode, endpointId)][\n            user\n        ].expirationTimestamp = expirationTimestamp;\n        emit ExtendedWhitelistExpiration(\n            airnode,\n            endpointId,\n            user,\n            msg.sender,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Called internally to set the whitelisting expiration of a\n    /// user for the Airnode–endpoint pair\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the whitelisting of the\n    /// user will expire\n    function setWhitelistExpiration_(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        uint64 expirationTimestamp\n    ) internal {\n        serviceIdToUserToWhitelistStatus[deriveServiceId(airnode, endpointId)][\n            user\n        ].expirationTimestamp = expirationTimestamp;\n        emit SetWhitelistExpiration(\n            airnode,\n            endpointId,\n            user,\n            msg.sender,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Called internally to set the whitelist status of a user\n    /// past expiration for the Airnode–endpoint pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @param status Whitelist status that the user will have past expiration\n    function setWhitelistStatusPastExpiration_(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        bool status\n    ) internal {\n        serviceIdToUserToWhitelistStatus[deriveServiceId(airnode, endpointId)][\n            user\n        ].whitelistedPastExpiration = status;\n        emit SetWhitelistStatusPastExpiration(\n            airnode,\n            endpointId,\n            user,\n            msg.sender,\n            status\n        );\n    }\n}\n"
    },
    "contracts/adminnable/Whitelister.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\n/// @title Contract where users are whitelisted for specific services (could be\n/// Airnode endpoints, dAPIs, beacons, etc.) until an expiration time or\n/// indefinitely\ncontract Whitelister {\n    struct WhitelistStatus {\n        uint64 expirationTimestamp;\n        bool whitelistedPastExpiration;\n    }\n\n    mapping(bytes32 => mapping(address => WhitelistStatus))\n        internal serviceIdToUserToWhitelistStatus;\n\n    /// @dev Reverts if the provided timestamp does not extend whitelist\n    /// expiration for the service–user pair\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the user will no longer\n    /// be whitelisted\n    modifier onlyIfTimestampExtends(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) {\n        require(\n            expirationTimestamp >\n                serviceIdToUserToWhitelistStatus[serviceId][user]\n                    .expirationTimestamp,\n            \"Expiration not extended\"\n        );\n        _;\n    }\n\n    /// @notice Called internally to check if a user is whitelisted to use the\n    /// service\n    /// @dev The user is whitelisted if the current timestamp is earlier than\n    /// the expiration of the temporary whitelisting for the service–user pair\n    /// or the service–user pair is whitelisted permanently. These two\n    /// conditions function independently, and the pair is considered\n    /// whitelisted even if only one of these apply.\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @return isWhitelisted If the user is whitelisted\n    function userIsWhitelisted(bytes32 serviceId, address user)\n        internal\n        view\n        returns (bool isWhitelisted)\n    {\n        WhitelistStatus\n            storage whitelistStatus = serviceIdToUserToWhitelistStatus[\n                serviceId\n            ][user];\n        return\n            whitelistStatus.whitelistedPastExpiration ||\n            whitelistStatus.expirationTimestamp > block.timestamp;\n    }\n}\n"
    },
    "contracts/rrp/authorizers/AirnodeRequesterRrpAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../adminnable/SelfAdminnable.sol\";\nimport \"./RequesterRrpAuthorizer.sol\";\nimport \"./interfaces/IAirnodeRequesterRrpAuthorizer.sol\";\n\n/// @title Authorizer contract that whitelists requesters where each Airnode is\n/// adminned by themselves\n/// @dev The Airnode address and the admins are also authorized even if they\n/// are not whitelisted explicitly\ncontract AirnodeRequesterRrpAuthorizer is\n    SelfAdminnable,\n    RequesterRrpAuthorizer,\n    IAirnodeRequesterRrpAuthorizer\n{\n    enum AdminRank {\n        Unauthorized,\n        Admin,\n        SuperAdmin\n    }\n\n    /// @notice Authorizer contracts use `AUTHORIZER_TYPE` to signal their type\n    uint256 public constant override AUTHORIZER_TYPE = 1;\n\n    /// @notice Called by an admin to extend the whitelist expiration of a user\n    /// for the Airnode–endpoint pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the user will no longer\n    /// be whitelisted\n    function extendWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        uint64 expirationTimestamp\n    ) external override onlyWithRank(airnode, uint256(AdminRank.Admin)) {\n        extendWhitelistExpiration_(\n            airnode,\n            endpointId,\n            user,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Called by a super admin to set the whitelisting expiration of a\n    /// user for the Airnode–endpoint pair\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the whitelisting of the\n    /// user will expire\n    function setWhitelistExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        uint64 expirationTimestamp\n    ) external override onlyWithRank(airnode, uint256(AdminRank.SuperAdmin)) {\n        setWhitelistExpiration_(airnode, endpointId, user, expirationTimestamp);\n    }\n\n    /// @notice Called by a super admin to set the whitelist status of a user\n    /// past expiration for the Airnode–endpoint pair\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param user User address\n    /// @param status Whitelist status that the user will have past expiration\n    function setWhitelistStatusPastExpiration(\n        address airnode,\n        bytes32 endpointId,\n        address user,\n        bool status\n    ) external override onlyWithRank(airnode, uint256(AdminRank.SuperAdmin)) {\n        setWhitelistStatusPastExpiration_(airnode, endpointId, user, status);\n    }\n\n    /// @notice Verifies the authorization status of a request\n    /// @dev This method has redundant arguments because all authorizer\n    /// contracts have to have the same interface and potential authorizer\n    /// contracts may require to access the arguments that are redundant here\n    /// @param requestId Request ID\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param sponsor Sponsor address\n    /// @param requester Requester address\n    /// @return Authorization status of the request\n    function isAuthorized(\n        bytes32 requestId, // solhint-disable-line no-unused-vars\n        address airnode,\n        bytes32 endpointId,\n        address sponsor, // solhint-disable-line no-unused-vars\n        address requester\n    ) external view override returns (bool) {\n        return\n            userIsWhitelisted(\n                deriveServiceId(airnode, endpointId),\n                requester\n            ) ||\n            adminnedToAdminToRank[airnode][requester] >=\n            uint256(AdminRank.Admin) ||\n            requester == airnode;\n    }\n}\n"
    },
    "contracts/adminnable/SelfAdminnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"./interfaces/ISelfAdminnable.sol\";\n\n/// @title Contract that implements multiple levels of admins for multiple\n/// \"adminned\" addresses independently\ncontract SelfAdminnable is ISelfAdminnable {\n    /// @notice Called to get the rank of an admin for the adminned address\n    mapping(address => mapping(address => uint256))\n        public\n        override adminnedToAdminToRank;\n\n    /// @dev Reverts if the caller's rank is not greater than or equal to\n    /// `rank` for the adminned address\n    /// @dev Adminned address always satisfies rank requirements\n    /// @param adminned Adminned address\n    /// @param rank Rank caller's rank will be compared to\n    modifier onlyWithRank(address adminned, uint256 rank) {\n        require(\n            adminnedToAdminToRank[adminned][msg.sender] >= rank ||\n                msg.sender == adminned,\n            \"Caller ranked low\"\n        );\n        _;\n    }\n\n    /// @notice Called by an admin of higher rank to set the rank of an admin\n    /// of lower rank for the adminned address\n    /// @dev Reverts if `newRank` is `type(uint256).max`\n    /// @param adminned Adminned address\n    /// @param targetAdmin Target admin address\n    /// @param newRank Rank to be set\n    function setRank(\n        address adminned,\n        address targetAdmin,\n        uint256 newRank\n    )\n        external\n        override\n        onlyWithRank(\n            adminned,\n            max(adminnedToAdminToRank[adminned][targetAdmin], newRank) + 1\n        )\n    {\n        // It should have already reverted if `adminned` was `address(0)`\n        assert(adminned != address(0));\n        require(targetAdmin != address(0), \"Target admin zero\");\n        adminnedToAdminToRank[adminned][targetAdmin] = newRank;\n        emit SetRank(adminned, msg.sender, targetAdmin, newRank);\n    }\n\n    /// @notice Called by an admin to decrease its rank for the adminned\n    /// address\n    /// @dev Reverts if `newRank` is `type(uint256).max`\n    /// @param adminned Adminned address\n    /// @param newRank Rank to be set\n    function decreaseSelfRank(address adminned, uint256 newRank)\n        external\n        override\n        onlyWithRank(adminned, newRank + 1)\n    {\n        // It should have already reverted if `adminned` was `address(0)`\n        assert(adminned != address(0));\n        adminnedToAdminToRank[adminned][msg.sender] = newRank;\n        emit DecreasedSelfRank(adminned, msg.sender, newRank);\n    }\n\n    /// @notice Called internally to compute the maximum between two unsigned\n    /// integers\n    /// @param a First unsigned integer\n    /// @param b Second unsigned integer\n    /// @return Larger of the two unsigned integers\n    function max(uint256 a, uint256 b) private pure returns (uint256) {\n        return a > b ? a : b;\n    }\n}\n"
    },
    "contracts/rrp/authorizers/interfaces/IAirnodeRequesterRrpAuthorizer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../../../adminnable/interfaces/ISelfAdminnable.sol\";\nimport \"./IRequesterRrpAuthorizer.sol\";\n\ninterface IAirnodeRequesterRrpAuthorizer is\n    ISelfAdminnable,\n    IRequesterRrpAuthorizer\n{}\n"
    },
    "contracts/adminnable/interfaces/ISelfAdminnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ninterface ISelfAdminnable {\n    event SetRank(\n        address indexed adminned,\n        address indexed callerAdmin,\n        address indexed targetAdmin,\n        uint256 newRank\n    );\n\n    event DecreasedSelfRank(\n        address indexed adminned,\n        address indexed admin,\n        uint256 newRank\n    );\n\n    function setRank(\n        address adminned,\n        address targetAdmin,\n        uint256 newRank\n    ) external;\n\n    function decreaseSelfRank(address adminned, uint256 newRank) external;\n\n    function adminnedToAdminToRank(address adminned, address admin)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/rrp/requesters/mock/MockRrpRequester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"../RrpRequester.sol\";\n\n/// @title A mock Airnode RRP requester contract\ncontract MockRrpRequester is RrpRequester {\n    event FulfilledRequest(bytes32 indexed requestId, bytes data);\n\n    mapping(bytes32 => bytes) public requestIdToData;\n\n    mapping(bytes32 => bool) private expectingRequestWithIdToBeFulfilled;\n\n    /// @param airnodeRrpAddress Airnode RRP contract address\n    constructor(address airnodeRrpAddress) RrpRequester(airnodeRrpAddress) {}\n\n    /// @notice A wrapper for the respective method at AirnodeRrp.sol for\n    /// testing\n    /// @param templateId Template ID\n    /// @param sponsor Sponsor address\n    /// @param sponsorWallet Sponsor wallet that is requested to fulfill\n    /// the request\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param parameters Parameters provided by the requester in addition to\n    /// the parameters in the template\n    function makeTemplateRequest(\n        bytes32 templateId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n    ) external {\n        bytes32 requestId = airnodeRrp.makeTemplateRequest(\n            templateId,\n            sponsor,\n            sponsorWallet,\n            fulfillAddress,\n            fulfillFunctionId,\n            parameters\n        );\n        expectingRequestWithIdToBeFulfilled[requestId] = true;\n    }\n\n    /// @notice A wrapper for the respective method at AirnodeRrp.sol for\n    /// testing\n    /// @param airnode Airnode address\n    /// @param endpointId Endpoint ID\n    /// @param sponsor Sponsor address\n    /// @param sponsorWallet Sponsor wallet that is requested to fulfill\n    /// the request\n    /// @param fulfillAddress Address that will be called to fulfill\n    /// @param fulfillFunctionId Signature of the function that will be called\n    /// to fulfill\n    /// @param parameters All request parameters\n    function makeFullRequest(\n        address airnode,\n        bytes32 endpointId,\n        address sponsor,\n        address sponsorWallet,\n        address fulfillAddress,\n        bytes4 fulfillFunctionId,\n        bytes calldata parameters\n    ) external {\n        bytes32 requestId = airnodeRrp.makeFullRequest(\n            airnode,\n            endpointId,\n            sponsor,\n            sponsorWallet,\n            fulfillAddress,\n            fulfillFunctionId,\n            parameters\n        );\n        expectingRequestWithIdToBeFulfilled[requestId] = true;\n    }\n\n    /// @notice A method to be called back by the respective method at\n    /// AirnodeRrp.sol for testing\n    /// @param requestId Request ID\n    /// @param data Data returned by the Airnode\n    function fulfill(bytes32 requestId, bytes calldata data)\n        external\n        onlyAirnodeRrp\n    {\n        require(\n            expectingRequestWithIdToBeFulfilled[requestId],\n            \"No such request made\"\n        );\n        delete expectingRequestWithIdToBeFulfilled[requestId];\n        requestIdToData[requestId] = data;\n        emit FulfilledRequest(requestId, data);\n    }\n\n    /// @notice A method to be called back by the respective method at\n    /// AirnodeRrp.sol for testing fulfillment failure\n    /// @param requestId Request ID\n    /// @param data Data returned by the Airnode\n    function fulfillAlwaysReverts(\n        bytes32 requestId, // solhint-disable-line no-unused-vars\n        bytes calldata data // solhint-disable-line no-unused-vars\n    ) external view onlyAirnodeRrp {\n        revert(\"Always reverts\");\n    }\n\n    /// @notice A method to be called back by the respective method at\n    /// AirnodeRrp.sol for testing fulfillment failure\n    /// @param requestId Request ID\n    /// @param data Data returned by the Airnode\n    function fulfillAlwaysRevertsWithNoString(\n        bytes32 requestId, // solhint-disable-line no-unused-vars\n        bytes calldata data // solhint-disable-line no-unused-vars\n    ) external view onlyAirnodeRrp {\n        revert(); // solhint-disable-line reason-string\n    }\n\n    /// @notice A method to be called back by the respective method at\n    /// AirnodeRrp.sol for testing fulfillment running out of gas\n    /// @param requestId Request ID\n    /// @param data Data returned by the Airnode\n    function fulfillAlwaysRunsOutOfGas(\n        bytes32 requestId, // solhint-disable-line no-unused-vars\n        bytes calldata data // solhint-disable-line no-unused-vars\n    ) external view onlyAirnodeRrp {\n        while (true) {}\n    }\n\n    /// @notice A wrapper for the respective method at AirnodeRrp.sol for\n    /// testing\n    /// @dev The withdrawal requested by calling this will revert because this\n    /// contract does not implement a default payable method\n    /// @param airnode Airnode address\n    /// @param sponsorWallet Sponsor wallet that the withdrawal is requested\n    /// from\n    function requestWithdrawal(address airnode, address sponsorWallet)\n        external\n    {\n        airnodeRrp.requestWithdrawal(airnode, sponsorWallet);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
